<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[ffmpeg添加图片水印的畸变问题]]></title>
      <url>%2F2016%2F12%2F12%2Fffmpeg-watermark%2F</url>
      <content type="text"><![CDATA[音视频添加图片水印时，SAR/DAR会造成水印随帧画面畸变 PAR/SAR/DAR定义 PAR(Pixel Aspect Ratio) 像素宽高比：单个像素的宽高比，通常该值为1，即正方形像素；若不为1，则为长方形像素。 SAR(Sample Aspect Ratio) 采样纵横比：视频横向对应的像素个数比上视频纵向的像素个数，即为我们通常提到的分辨率。 DAR(Display Aspect Ratio) 显示宽高比：终端显示时，播放画面的宽高比。 计算公式SAR x PAR = DAR 通过上述公式，可以根据SAR、PAR、DAR中的两个计算出另外一个 ffmpeg中的分辨率、SAR、DAR先来看一个样例视频的视频信息12345678&quot;width&quot;: 1920,&quot;height&quot;: 1080,&quot;coded_width&quot;: 1920,&quot;coded_height&quot;: 1088,&quot;has_b_frames&quot;: 2,&quot;sample_aspect_ratio&quot;: &quot;1:1&quot;,&quot;display_aspect_ratio&quot;: &quot;16:9&quot;,&quot;pix_fmt&quot;: &quot;yuv420p&quot;, 分析上述样例视频的avinfo信息可知： 分辨率=1920x108 sar=1:1 dar=16:9 实际上，由于通常PAR=1:1，使得帧画面的宽高比=分辨率（即宽高像素数目） 此时，ffmpeg对于分辨率、sar、dar有如下公式： W/H * SAR = DAR 上述样例视频，1920/1080 * (1/1) = 16:9 再看另外一个样例视频的视频信息12345678&quot;width&quot;: 480,&quot;height&quot;: 320,&quot;coded_width&quot;: 480,&quot;coded_height&quot;: 320,&quot;has_b_frames&quot;: 2,&quot;sample_aspect_ratio&quot;: &quot;32:27&quot;,&quot;display_aspect_ratio&quot;: &quot;16:9&quot;,&quot;pix_fmt&quot;: &quot;yuv420p&quot;, 上述视频，480/320 * (32/27) = 16/9 水印畸变播放形变一般视频终端播放是否发生形变，可以根据如下参数来判定： 当SAR=1:1时，分辨率宽高比 = DAR，表示帧画面在终端播放时不会产生形变 当SAR!=1:1时，分辨率宽高比 != DAR，表示帧画面在终端播放时会产生形变 终端播放形变方式形变方式通常可以分为三种： 保持短边不变，长边缩放 保持长边不变，短边缩放 长边短边同时缩放 若以样例视频二为例，上述三种形变方式可得： 原始画面480x320，短边保持不变，此时H=320,DAR=16/9，得W=320/9*16=569,即长边缩放比为569/480=1.185 原始画面480x320，长边边保持不变，此时W=480,DAR=16/9,得H=480/16*9=270，即短边的缩放比为270/320=0.84375 根据播放器实际情况发生变化 播放形变带来的水印形变图片水印通常直接合成在原始帧画面中，故播放端的形变会连带造成水印产生畸变 以上述形变方式1为例，假设为原始视频打上一个40x40的方形水印，在终端播放时，长边会进行1.185倍的缩放，故实际水印显示大小约为47x40，畸变成为一个长方形水印 图片水印畸变的解决方案在实际的生产应用中，有些需求水印要保持原始的长宽比，不能发生畸变，此时需要对图片水印畸变进行修正 由于播放形变取决的终端行为，故对水印畸变的情况并不能准确预测，不同的畸变模式的修正方式不一样，博主仅能据工作中的实际处理情况给出一些解决方案，欢迎大家指正~ （未完待续）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bochs+gdb源码级调试linux0.12内核测试环境构建]]></title>
      <url>%2F2011%2F05%2F31%2Fbochs-gdb-linux0-12-debug%2F</url>
      <content type="text"><![CDATA[bochs+gdb搭建linux0.12内核源码调试环境 前言之前都是用的bochs自带的debug功能，但是linux内核大部分都是用C语vv言来实现的，若仅通过反汇编的汇编来学习，太累了。。。 所以今天花了一个上午的时间，搭建起了bochs+gbd的联调环境。 安装bochs首先还是要安装bochs，仍然是推荐使用最新的版本（2.4.6），如果使用像2.3.6等老版本，也许会导致后面与gdb无法远程连接（NND，就是这个恶心的问题浪费了我几个小时。。。） linux上还是要从bochs的源码编译开始安装，bin文件安装的版本无法提供调试功能。 配置bochs源码时，输入命令 ./configure –enable-gdb-stub，然后使用make和sudo make install命令完成安装。 安装时可能会遇到X windows库不全的情况，可以通过apt-get安装xorg-dev解决。 如果是从source code进行编译安装时，有可能会用到的两个组件分别是build-essential和libxrandr-dev，各自作用请自行搜索～ 配置bochs配置bochs虚拟机环境需要一个.bxrc文件和生产一个根文件系统镜像文件，建议直接到oldlinux上下载一个linux-0.11-gdb-rh9-050619.tar.gz，其中已经包含了配置好的这两个文件，另外在linux文件夹下有linux0.11的源码。 .bxrc文件中主要是添加了一条调试信息1gdbstub: enable=1, port=1234, text_base=0, data_base=0, bss_base=0 另外，这个bxrc文件中需要稍稍修改一些东西： romimage: file=$BXSHARE/BIOS-bochs-latest, address=0xf0000 改成 romimage: file=$BXSHARE/BIOS-bochs-latest floppy_command_delay: 50000 改成 #floppy_command_delay: 50000 3.ips: 4000000 改成 cpu: count=1, ips=4000000 使用bochs进行联机调试 打开两个终端。 一个终端进入到linux-gdb-rh9/，运行程序”./run”，此时窗口显示等待信息“wait for gdb connection on localhost:1234” 另一个终端进入linux-gdb-rh9/linux/，运行 gdb tools/system 在gdb窗口中输入b main（在main函数处下断） 输入target remote localhost:1234 ，连接到bochs虚拟机上 输入c，让程序持续运行，直到终端在main函数中 可以开始使用gdb进行源码调试了^_^ Tips 早期源码默认的汇编编译器为gas，链接器为gld，所以在Makefile文件中显示声明as=gas ld=gld。而在ubuntu 11.04中，gcc早已成为默认的编译器了，所以如果是另外下载的源码，需要将Makefile中的as=gas ld=gld改成 as=as， ld=ld 先写到这，有在想到的继续啊~~~^_^]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[A20地址线的一点理解]]></title>
      <url>%2F2011%2F05%2F27%2Fa20-bus%2F</url>
      <content type="text"><![CDATA[A20地址线 Linux内核实现及系统启动引导 A20地址线先来看看A20地址线的由来和历史遗留问题（纯搬运）： 1981年8月，IBM公司最初推出的个人计算机IBM PC使用的CPU是Intel 8088。在该微机中地址线只有20根(A0 – A19)。在当时内存RAM只有几百KB或不到1MB时，20根地址线已足够用来寻址这些内存。其所能寻址的最高地址是0xffff:0xffff，也即0x10ffef。对于超出0x100000(1MB)的寻址地址将默认地环绕到0x0ffef。当IBM公司于1985年引入AT机时，使用的是Intel 80286 CPU，具有24根地址线，最高可寻址16MB，并且有一个与8088完全兼容的实模式运行方式。然而，在寻址值超过1MB时它却不能象8088那样实现地址寻址的环绕。但是当时已经有一些程序是利用这种地址环绕机制进行工作的。为了实现完全的兼容性，IBM公司发明了使用一个开关来开启或禁止0x100000地址比特位。由于在当时的8042键盘控制器上恰好有空闲的端口引脚（输出端口P2，引脚P21），于是便使用了该引脚来作为与门控制这个地址比特位。该信号即被称为A20。如果A20为零，则比特20及以上地址都被清除。从而实现了兼容性。 由于在机器启动时，默认条件下，A20地址线是禁止的，所以操作系统必须使用适当的方法来开启它。但是由于各种兼容机所使用的芯片集不同，要做到这一点却是非常的麻烦。因此通常要在几种控制方法中选择。 A20地址线的控制对A20信号线进行控制的常用方法是通过设置键盘控制器的端口值。下面引用一段linux0.11的源码（setup.s）: 1234567891011121314151617 call empty_8042 mov al,#0xd1 out #0x64,al call empty_8042 mov al,#0xdf out #0x60,al call empty_8042 ... empty_8042: .word 0x00eb,0x00eb in al,#0x64 test al,#2 jnz empty_8042 ret 贴一下啊head.s中的代码(这里转成Intel汇编格式，源码是AT&amp;A汇编，看着蛋疼。。)：123456 xor eax,eaxl: inc eax mov [0x000000],eax; cmp [0x100000],eax; je lb 向0x000000字节处数据改为1，查看0x100000处数据是否同时变成了1，若是则A20地址线没用开启；否则开启成功。 Intel 8042芯片解释一下Intel 8042芯片（又是搬运。。。）： ntel8024是intel公司的一款键盘控制器芯片,它为x86系统中的标准配置.虽然名为键盘控制器,但是鼠标也是由其控制的. 键盘通常使用IRQ1.鼠标通常使用IRQ12.IRQ1和IRQ12都是连接在键盘控制器上的.对应intel8042的两个端口. 配给键盘控制器的I/O端口有四个,分别是0x60~0x64.在大部分情况中,只会使用到0x60和0x64.其余0x61~0x64的存在主要是为了兼容XT.可以将0x64看做是状态寄存器.0x60看成是数据寄存器.有时在给键盘控制器下指令的时候,这两个端口都要用到.两者配合来达到下指令与参数的目的. 向i8042发送命令: 我们需要先把命令发送到0x64端口， 然后紧接着把这个命令的参数发送到0x60端口， 然后我们可以通过读0x60端口，获得i8042返回给我们的数据。]]></content>
    </entry>

    
  
  
</search>
