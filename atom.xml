<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮生半日闲</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.snowwalf.com/"/>
  <updated>2017-02-20T14:11:56.000Z</updated>
  <id>http://blog.snowwalf.com/</id>
  
  <author>
    <name>snowwalf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>句柄泄露围捕记</title>
    <link href="http://blog.snowwalf.com/2017/02/18/%E5%8F%A5%E6%9F%84%E6%B3%84%E9%9C%B2%E5%9B%B4%E6%8D%95%E8%AE%B0/"/>
    <id>http://blog.snowwalf.com/2017/02/18/句柄泄露围捕记/</id>
    <published>2017-02-18T04:13:44.000Z</published>
    <updated>2017-02-20T14:11:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>记录实际的生产环境中遇到的BUG及解决问题的一些经验</em><br><a id="more"></a></p>
<h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><p>博主负责的一个在线图片处理服务，存在长时间（超过20天）运行后会服务进程出错退出的问题。运维小伙伴把情况报到开发这，并没有更多的信息😵😵😵</p>
<h1 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h1><h2 id="产品服务"><a href="#产品服务" class="headerlink" title="产品服务"></a>产品服务</h2><p>该产品是一个云计算图片处理服务（参见七牛数据处理服务），后台使用到了imageMagick SDK的基本图片处理功能。</p>
<p>服务同时部署在物理服务器和容器中，多个异地区域机房，但实际仅在其中一个机房的物理集群中发生进程重启的情况（服务使用supervisorctl托管，异常退出后自动重启）。</p>
<p>线上服务并未开启coredump；出core日志调用栈仅显示捕获signal 11，回放上一条的服务请求并不能触发错误。</p>
<p>查看该服务在此DC中监控情况，发现峰值TPS在40K+，日均TPS约在20K左右，CPU、内存、磁盘和网络带宽均在警戒值以下，服务器句柄数保持在最高维持在10K左右。</p>
<h2 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a>诊断</h2><p>根据经验，长时间运行后服务进程出错退出，往往是因为存在资源泄露，例如内存泄露、句柄泄露、临时文件未删除等。</p>
<p>调取服务进程的物理资源使用情况进行分析，CPU、内存均无显著异常，但文件句柄使用情况存在问题</p>
<img src="http://ohgqsah1g.bkt.clouddn.com/20170218/fd-leak.png" class="fd-process" title="服务句柄量">
<p>从上图中可以看出，服务句柄数基本呈线性增长，陡降的地方为服务进程被重启了（比如服务更新发布），这对于一个长期运行的服务端程序是不合理的。</p>
<p>故能初步判断出，程序存在文件句柄泄露。</p>
<h1 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h1><h2 id="线上分析"><a href="#线上分析" class="headerlink" title="线上分析"></a>线上分析</h2><p>该服务部署在多个DC，服务发生进程重启均集中在一个DC。该DC服务请求最高，峰值TPS可以达到30+K；相对其他DC的请求量要小一个数量级。</p>
<p>登录服务部署在DC的一台服务器，使用lsof查询服务进行FD使用情况，可以发现存在大量的FD处于deleted状态（标记删除但仍未释放）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">lsof -p 9291  | grep deleted</div><div class="line"></div><div class="line">...</div><div class="line">qboximage 9291 qboxserver 1228r      REG        8,1     31346    4487983 /home/qboxserver/image6/_package/run/fopd_tmpdir/mogr2_244b_34d98ac907d245_452020_1d0 (deleted)</div><div class="line">qboximage 9291 qboxserver 1229r      REG        8,1     18542    4487917 /home/qboxserver/image6/_package/run/fopd_tmpdir/mogr2_244b_34d9871a4080c3_44d568_364 (deleted)</div><div class="line">qboximage 9291 qboxserver 1230r      REG        8,1     37602    4488004 /home/qboxserver/image6/_package/run/fopd_tmpdir/mogr2_244b_34d9858c894d31_44b62d_25f (deleted)</div><div class="line">qboximage 9291 qboxserver 1231r      REG        8,1     50062    4487872 /home/qboxserver/image6/_package/run/fopd_tmpdir/mogr2_244b_34d97fe5e79906_44401e_26d (deleted)</div><div class="line">qboximage 9291 qboxserver 1232r      REG        8,1     12640    4487898 /home/qboxserver/image6/_package/run/fopd_tmpdir/mogr2_244b_34d9894b49bfcc_45018b_2d9 (deleted)</div><div class="line">qboximage 9291 qboxserver 1233r      REG        8,1     49844    4488020 /home/qboxserver/image6/_package/run/fopd_tmpdir/mogr2_244b_34d989f6040b2d_450f17_2bf (deleted)</div><div class="line">qboximage 9291 qboxserver 1239r      REG        8,1     10772    4487929 /home/qboxserver/image6/_package/run/fopd_tmpdir/mogr2_244b_34d980dc71106c_4454e1_1ef (deleted)</div><div class="line">qboximage 9291 qboxserver 1240r      REG        8,1     73538    4487977 /home/qboxserver/image6/_package/run/fopd_tmpdir/mogr2_244b_34d989d52655ea_450c7e_1b5 (deleted)</div><div class="line">...</div></pre></td></tr></table></figure>
<p>进程重启后，单日可堆积未释放的FD到500个左右</p>
<h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><p>用lsof查看未释放的FD，发现都是指向服务流程中的临时文件，文件路径中包含唯一HASH字符串。</p>
<p>在日志系统中检索上述hash值，发现都是同一种请求类型，即webp图片转成webp请求，猜测可能与webp处理例程有关。</p>
<p>随机抓取几个请求，任选一台服务器，进行请求回访，结合日志系统使用lsof检索，发现确实每一个webp转webp的请求都会产生一个FD泄露。构造类似的请求，发送线上其他DC进行处理，通过后台日志+lsof，发现同样也发生了FD泄露。</p>
<p>抓取线上文件，将线上服务请求在本地开发环境进行回放，同样也可以产生句柄泄露。</p>
<p>至此，BUG可以稳定复现，可以确定针对webp转webp的请求存在句柄泄露。</p>
<h1 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h1><h2 id="泄露定位"><a href="#泄露定位" class="headerlink" title="泄露定位"></a>泄露定位</h2><p>那么问题来了，泄露发生在什么地方呢？该服务端http server使用go语言，图片处理使用cgo调用开源库imageMagick的SDK，服务代码就有上千行，开源库部分博主还不够熟悉😳😳😳</p>
<p>很显然，生啃代码去找BUG绝对不是个好主意，需要另想办法。</p>
<p>简单浏览imageMagick的代码，可以发现大部分都是C语言写的（Magick++部分进行了面向对象的封装，使用了C++）。感谢男神谭浩强，博主还记得，C语言中涉及文件句柄的函数主要有open、close、fopen和fclose，也是想到了可以通过Hack底层libc的库函数。</p>
<p>废话不多说，上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;dlfcn.h&gt;</div><div class="line">#include &lt;execinfo.h&gt;</div><div class="line"></div><div class="line">typedef int(*OPEN) (const char * pathname, int flags);</div><div class="line">typedef int(*CLOSE) (int fildes);</div><div class="line">typedef FILE*(*FOPEN) (const char * path, const char * mode);</div><div class="line">typedef int(*FCLOSE)(FILE* stream);</div><div class="line"></div><div class="line"></div><div class="line">/* 打印调用栈的最大深度 */</div><div class="line">#define DUMP_STACK_DEPTH_MAX 16</div><div class="line">void dump_trace() &#123;</div><div class="line">    void *stack_trace[DUMP_STACK_DEPTH_MAX] = &#123;0&#125;;</div><div class="line">    char **stack_strings = NULL;</div><div class="line">    int stack_depth = 0;</div><div class="line">    int i = 0;</div><div class="line"></div><div class="line">    /* 获取栈中各层调用函数地址 */</div><div class="line">    stack_depth = backtrace(stack_trace, DUMP_STACK_DEPTH_MAX);</div><div class="line"></div><div class="line">    /* 查找符号表将函数调用地址转换为函数名称 */</div><div class="line">    stack_strings = (char **)backtrace_symbols(stack_trace, stack_depth);</div><div class="line">    if (NULL == stack_strings) &#123;</div><div class="line">        printf(&quot; Memory is not enough while dump Stack Trace! \r\n&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* 打印调用栈 */</div><div class="line">    printf(&quot; Stack Trace: \r\n&quot;);</div><div class="line">    for (i = 0; i &lt; stack_depth; ++i) &#123;</div><div class="line">        printf(&quot; [%d] %s \r\n&quot;, i, stack_strings[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* 获取函数名称时申请的内存需要自行释放 */</div><div class="line">    free(stack_strings);</div><div class="line">    stack_strings = NULL;</div><div class="line"></div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int open(const char * pathname, int flags)</div><div class="line">&#123;</div><div class="line">    static void *handle = NULL;</div><div class="line">    static OPEN old_open = NULL;</div><div class="line">    if( !handle )</div><div class="line">    &#123;</div><div class="line">        handle = dlopen(&quot;libc.so.6&quot;, RTLD_LAZY);</div><div class="line">        old_open = (OPEN)dlsym(handle, &quot;open&quot;);</div><div class="line">    &#125;</div><div class="line">    int fd = old_open(pathname, flags); </div><div class="line">    printf(&quot;open function invoked. path=[%s] flag=&lt;%d&gt; fd=[%d]\n&quot;, pathname, flags, fd);</div><div class="line">    dump_trace();</div><div class="line">    return fd;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int close(int fildes)</div><div class="line">&#123;</div><div class="line">    static void *handle = NULL;</div><div class="line">    static CLOSE old_close = NULL;</div><div class="line">    if( !handle )</div><div class="line">    &#123;</div><div class="line">        handle = dlopen(&quot;libc.so.6&quot;, RTLD_LAZY);</div><div class="line">        old_close = (CLOSE)dlsym(handle, &quot;open&quot;);</div><div class="line">    &#125;</div><div class="line">    printf(&quot;close function invoked. fd=[%d] flag=&lt;%d&gt;\n&quot;, fildes);</div><div class="line">    dump_trace();</div><div class="line">    return old_close(fildes);</div><div class="line">&#125;</div><div class="line"></div><div class="line">FILE* fopen(const char * path, const char * mode)</div><div class="line">&#123;</div><div class="line">    static void *handle = NULL;</div><div class="line">    static FOPEN old_fopen = NULL;</div><div class="line">    if( !handle )</div><div class="line">    &#123;</div><div class="line">        handle = dlopen(&quot;libc.so.6&quot;, RTLD_LAZY);</div><div class="line">        old_fopen = (FOPEN)dlsym(handle, &quot;fopen&quot;);</div><div class="line">    &#125;</div><div class="line">    FILE* f =  old_fopen(path,mode);</div><div class="line">    printf(&quot;fopen function invoked. path=[%s] flag=&lt;%s&gt; FILE=[%p]\n&quot;, path, mode,f);</div><div class="line">    dump_trace();</div><div class="line">    return f;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int fclose(FILE* stream)</div><div class="line">&#123;</div><div class="line">    static void *handle = NULL;</div><div class="line">    static FCLOSE old_fclose = NULL;</div><div class="line">    if( !handle )</div><div class="line">    &#123;</div><div class="line">        handle = dlopen(&quot;libc.so.6&quot;, RTLD_LAZY);</div><div class="line">        old_fclose = (FCLOSE)dlsym(handle, &quot;fclose&quot;);</div><div class="line">    &#125;</div><div class="line">    printf(&quot;fclose function invoked. FILE=[%p]\n&quot;, stream);</div><div class="line">    dump_trace();</div><div class="line">    return old_fclose(stream);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码勾了libc中的open、close、fopen和fclose函数，打印出了调用参数，以及函数调用堆栈</p>
<p>编译成动态链接库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -fPIC -shared -o hook.so hook.c -ldl</div></pre></td></tr></table></figure></p>
<p>手动挂载动态链接库，本地启动服务程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LD_LIBRARY_PATH=./hook.so ./qboximage -f ./qboximage.conf</div></pre></td></tr></table></figure></p>
<p>重新发送之前的请求，可以从日志中获取对应FD的情况如下：<br>第一次句柄打开(fopen)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">fopen function invoked. path=[/workspace/tmp/mogr2_7_34d6663757bf64_1_31a] flag=&lt;rb&gt; FILE=[0x7fe4b403a5b0]</div><div class="line"> Stack Trace: </div><div class="line"></div><div class="line"> [0] /root/hook.so(dump_trace+0x52) [0x7fe4c8e609a7] </div><div class="line"></div><div class="line"> [1] /root/hook.so(fopen+0x96) [0x7fe4c8e60c07] </div><div class="line"></div><div class="line"> [2] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(OpenBlob+0x6eb) [0x7fe4c85112eb] </div><div class="line"></div><div class="line"> [3] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(SetImageInfo+0x262) [0x7fe4c85d8332] </div><div class="line"></div><div class="line"> [4] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(ReadImage+0xa1) [0x7fe4c85454a1] </div><div class="line"></div><div class="line"> [5] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(ReadImages+0x15b) [0x7fe4c85465db] </div><div class="line"></div><div class="line"> [6] /root/fop_depend/_package/lib_for_fopd/libMagickWand-6.Q16.so.2(ConvertImageCommand+0x993) [0x7fe4c8b83d53] </div><div class="line"></div><div class="line"> [7] /root/fop_depend/_package/lib_for_fopd/libMagickWand-6.Q16.so.2(MagickCommandGenesis+0x6b3) [0x7fe4c8bf0b63] </div><div class="line"></div><div class="line"> [8] /root/dora-image(_cgo_f771dc2ebe72_Cfunc_myConvert+0x4b) [0x86cd5b] </div><div class="line"></div><div class="line"> [9] /root/dora-image() [0x475770]</div></pre></td></tr></table></figure></p>
<p>对应的句柄关闭：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">fclose function invoked. FILE=[0x7fe4b403a5b0]</div><div class="line"> Stack Trace: </div><div class="line"></div><div class="line"> [0] /root/hook.so(dump_trace+0x52) [0x7fe4c8e609a7] </div><div class="line"></div><div class="line"> [1] /root/hook.so(fclose+0x6f) [0x7fe4c8e60c7c] </div><div class="line"></div><div class="line"> [2] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(CloseBlob+0x241) [0x7fe4c8510b21] </div><div class="line"></div><div class="line"> [3] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(SetImageInfo+0x343) [0x7fe4c85d8413] </div><div class="line"></div><div class="line"> [4] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(ReadImage+0xa1) [0x7fe4c85454a1] </div><div class="line"></div><div class="line"> [5] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(ReadImages+0x15b) [0x7fe4c85465db] </div><div class="line"></div><div class="line"> [6] /root/fop_depend/_package/lib_for_fopd/libMagickWand-6.Q16.so.2(ConvertImageCommand+0x993) [0x7fe4c8b83d53] </div><div class="line"></div><div class="line"> [7] /root/fop_depend/_package/lib_for_fopd/libMagickWand-6.Q16.so.2(MagickCommandGenesis+0x6b3) [0x7fe4c8bf0b63] </div><div class="line"></div><div class="line"> [8] /root/dora-image(_cgo_f771dc2ebe72_Cfunc_myConvert+0x4b) [0x86cd5b] </div><div class="line"></div><div class="line"> [9] /root/dora-image() [0x475770]</div></pre></td></tr></table></figure></p>
<p>第二次句柄打开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">fopen function invoked. path=[/workspace/tmp/mogr2_7_34d6663757bf64_1_31a] flag=&lt;rb&gt; FILE=[0x7fe4b403de50]</div><div class="line"> Stack Trace: </div><div class="line"></div><div class="line"> [0] /root/hook.so(dump_trace+0x52) [0x7fe4c8e609a7] </div><div class="line"></div><div class="line"> [1] /root/hook.so(fopen+0x96) [0x7fe4c8e60c07] </div><div class="line"></div><div class="line"> [2] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(OpenBlob+0x6eb) [0x7fe4c85112eb] </div><div class="line"></div><div class="line"> [3] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(+0x30aada) [0x7fe4c8791ada] </div><div class="line"></div><div class="line"> [4] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(ReadImage+0x198) [0x7fe4c8545598] </div><div class="line"></div><div class="line"> [5] /root/fop_depend/_package/lib_for_fopd/libMagickCore-6.Q16.so.2(ReadImages+0x15b) [0x7fe4c85465db] </div><div class="line"></div><div class="line"> [6] /root/fop_depend/_package/lib_for_fopd/libMagickWand-6.Q16.so.2(ConvertImageCommand+0x993) [0x7fe4c8b83d53] </div><div class="line"></div><div class="line"> [7] /root/fop_depend/_package/lib_for_fopd/libMagickWand-6.Q16.so.2(MagickCommandGenesis+0x6b3) [0x7fe4c8bf0b63] </div><div class="line"></div><div class="line"> [8] /root/dora-image(_cgo_f771dc2ebe72_Cfunc_myConvert+0x4b) [0x86cd5b] </div><div class="line"></div><div class="line"> [9] /root/dora-image() [0x475770]</div></pre></td></tr></table></figure></p>
<p>然后就么有关闭了。。。好吧，至此确定了FD在这里落跑了</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>那么问题又来了，根据调用堆栈，可以看到第二次调用fopen的是OpenBlob函数。grep了一把imageMagick的代码，发现有好几十处。。。博主最恨这种大海捞针的看代码😠，一定要再想想办法</p>
<p>既然有了调用堆栈，也就有了函数起始地址和调用偏移地址，为啥不反汇编下代码，减轻看代码的工作量呢？</p>
<p>首先，看调用堆栈，发现所有imageMagick调用都在动态链接库libMagickCore-6.Q16.so.2中。需要down一份线上同版本的imageMagick代码（v6.9.2，实测最新代码也要同样问题），打开-g编译选项，替换掉开发环境原有的libMagickCore-6.Q16.so.2库，重复之前的调试步骤，获得新的调用堆栈。博主本地常年用的调试版so，故省略该步。。。</p>
<p>然后，使用objdump反汇编该动态链接库，比较大，需要耐心等待<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objdump -l -DS ./libMagickCore-6.Q16.so.2 &gt; image.dump</div></pre></td></tr></table></figure></p>
<p>查找第二次OpenBlob的调用地址，.text段，偏移地址+0x30aada<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/root/ImageMagick-6.9.1-2/coders/webp.c:250</div><div class="line">  30aada:       85 c0                   test   %eax,%eax</div><div class="line">  30aadc:       0f 84 92 00 00 00       je     30ab74 &lt;ReadWEBPImage+0x124&gt;</div><div class="line">WebPInitDecoderConfig():</div><div class="line">/usr/local/include/webp/decode.h:466</div><div class="line">  30aae2:       4c 8d 6c 24 40          lea    0x40(%rsp),%r13</div><div class="line">  30aae7:       be 03 02 00 00          mov    $0x203,%esi</div><div class="line">  30aaec:       4c 89 ef                mov    %r13,%rdi</div><div class="line">  30aaef:       e8 0c 1a d6 ff          callq  6c500 &lt;WebPInitDecoderConfigInternal@plt&gt;</div></pre></td></tr></table></figure></p>
<p>抓到了，问题出在coders/webp.c，第250行。。。</p>
<h1 id="BUG解决"><a href="#BUG解决" class="headerlink" title="BUG解决"></a>BUG解决</h1><p>定位到了出错代码位置就好办了。经过对代码的分析，不难看出，imageMagick在webp的解包器中使用OpenBlob打开了源文件，返回前忘记关闭了。。。</p>
<p>ps：博主发文前，提交的fix pr已被master代码合并，故上述问题官方最新代码已修复</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;记录实际的生产环境中遇到的BUG及解决问题的一些经验&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="码经" scheme="http://blog.snowwalf.com/categories/%E7%A0%81%E7%BB%8F/"/>
    
    
      <category term="imageMagick" scheme="http://blog.snowwalf.com/tags/imageMagick/"/>
    
      <category term="文件句柄泄露" scheme="http://blog.snowwalf.com/tags/%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>ImageMagick工具之Identify分析</title>
    <link href="http://blog.snowwalf.com/2017/01/25/ImageMagick%E5%B7%A5%E5%85%B7%E4%B9%8BIdentify%E5%88%86%E6%9E%90/"/>
    <id>http://blog.snowwalf.com/2017/01/25/ImageMagick工具之Identify分析/</id>
    <published>2017-01-25T02:54:55.000Z</published>
    <updated>2017-01-25T03:13:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>摘要：分析ImageMagick工具中identify的使用以及结果内容说明</em><br><a id="more"></a></p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ identify example.png</div><div class="line">-&gt; example.png PNG 750x404 750x404+0+0 8-bit sRGB 103KB 0.000u 0:00.000</div></pre></td></tr></table></figure>
<h2 id="输出分析"><a href="#输出分析" class="headerlink" title="输出分析"></a>输出分析</h2><table>
<thead>
<tr>
<th>项目名称</th>
<th>说明</th>
<th>示例项</th>
</tr>
</thead>
<tbody>
<tr>
<td>文件名</td>
<td>图片文件的文件名</td>
<td>example.png</td>
</tr>
<tr>
<td>图片格式</td>
<td>图片编码格式</td>
<td>PNG</td>
</tr>
<tr>
<td>像素大小</td>
<td>描述图片大小，单位为像素</td>
<td>750x404</td>
</tr>
<tr>
<td>几何属性（Geometry）</td>
<td>描述了图片的大小和相对位置，格式<width>x<height>{+-}<xoffset>{+-}<yoffset></yoffset></xoffset></height></width></td>
<td>750x404+0+0</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;摘要：分析ImageMagick工具中identify的使用以及结果内容说明&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="ImageMagick" scheme="http://blog.snowwalf.com/categories/ImageMagick/"/>
    
    
      <category term="图片" scheme="http://blog.snowwalf.com/tags/%E5%9B%BE%E7%89%87/"/>
    
      <category term="ImageMagick" scheme="http://blog.snowwalf.com/tags/ImageMagick/"/>
    
      <category term="identify" scheme="http://blog.snowwalf.com/tags/identify/"/>
    
  </entry>
  
  <entry>
    <title>彩色模型</title>
    <link href="http://blog.snowwalf.com/2017/01/22/%E5%BD%A9%E8%89%B2%E6%A8%A1%E5%9E%8B/"/>
    <id>http://blog.snowwalf.com/2017/01/22/彩色模型/</id>
    <published>2017-01-22T11:50:18.000Z</published>
    <updated>2017-01-22T11:52:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>摘要： 介绍图片彩色模型的基本知识</em><br><a id="more"></a></p>
<h1 id="概念简介"><a href="#概念简介" class="headerlink" title="概念简介"></a>概念简介</h1><h2 id="彩色模型"><a href="#彩色模型" class="headerlink" title="彩色模型"></a>彩色模型</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>色彩模型是描述使用一组值（通常使用三个、四个值或者颜色成分）表示颜色方法的抽象数学模型。<br>但是一个与绝对色彩空间没有函数映射关系的色彩模型或多或少地都是与特定应用要求几乎没有关系的任意色彩系统。</p>
<footer><strong>@Wiki</strong><cite><a href="https://zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%96%93" target="_blank" rel="external">zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%96%93</a></cite></footer></blockquote>
<h3 id="常见彩色模型"><a href="#常见彩色模型" class="headerlink" title="常见彩色模型"></a>常见彩色模型</h3><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>RGB</td>
<td>最通用的面向硬件的模型</td>
<td>彩色显示器，彩色视频摄像机</td>
</tr>
<tr>
<td>CYM</td>
<td>面向印刷</td>
<td>印刷，彩色打印机</td>
</tr>
<tr>
<td>HSI</td>
<td>面向人眼</td>
<td></td>
</tr>
<tr>
<td>YUV</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="彩色深度"><a href="#彩色深度" class="headerlink" title="彩色深度"></a>彩色深度</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p>色彩深度计算机图形学领域表示在位图或者视频帧缓冲区中储存1像素的颜色所用的位数，它也称为位/像素（bpp）。色彩深度越高，可用的颜色就越多。</p>
<footer><strong>@Wiki</strong><cite><a href="https://zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9%E6%B7%B1%E5%BA%A6" target="_blank" rel="external">zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9%E6%B7%B1%E5%BA%A6</a></cite></footer></blockquote>
<h3 id="常见彩色深度"><a href="#常见彩色深度" class="headerlink" title="常见彩色深度"></a>常见彩色深度</h3><p>彩色深度是用“n位颜色”（n-bit colour）来说明的。若深度是n位，即有2^n种颜色选择，而储存每像素所用的位数就是n比特。</p>
<table>
<thead>
<tr>
<th style="text-align:left">位数</th>
<th>颜色种数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td>2</td>
<td>单色光，黑白二色，用于compact Macintoshes。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td>4</td>
<td>CGA，用于gray-scale早期的NeXTstation及color Macintoshes。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td>8</td>
<td>用于大部分早期的电脑显示器。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td>16</td>
<td>用于EGA及不常见及在更高的分辨率的VGA标准，color Macintoshes</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td>32</td>
<td>用于Original Amiga chipset。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td>64</td>
<td>用于Original Amiga chipset。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td>128</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td>256</td>
<td>用于最早期的彩色Unix工作站，低分辨率的VGA，Super VGA，AGA，color Macintoshes。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td>512</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td>1024</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td></td>
<td>用于部分硅谷图形系统，Neo Geo，彩色NeXTstation及Amiga系统于HAM mode。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td></td>
<td>用于部分color Macintoshes。</td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td>16777216</td>
<td>真彩色，能提供比肉眼能识别更多的颜色，用于拍摄照片。</td>
</tr>
</tbody>
</table>
<h1 id="RGB彩色模型"><a href="#RGB彩色模型" class="headerlink" title="RGB彩色模型"></a>RGB彩色模型</h1><p>RGB模型起源于采用阴极射线管的彩色电视，每种颜色出现在红、绿、蓝的原色光谱分量重。</p>
<h2 id="彩色空间坐标系"><a href="#彩色空间坐标系" class="headerlink" title="彩色空间坐标系"></a>彩色空间坐标系</h2><p>模型基于笛卡尔坐标系，xyz轴分别代表RGB，彩色子空间如下图所示<br><img src="http://ohgqsah1g.bkt.clouddn.com/rgb-model.jpg" class="rgb-color-model" title="RGB彩色立方体示意图"></p>
<p>该模型为加色模型，坐标原点表示黑色，（1，1，1）表示白色，R/G/B值取值范围在[0,1]</p>
<h2 id="24比特彩色深度"><a href="#24比特彩色深度" class="headerlink" title="24比特彩色深度"></a>24比特彩色深度</h2><p>在RGB空间中，用于表示每个像素的比特数称为 <em><em>像素深度</em></em>。</p>
<p>RGB彩色模型中的图像有3个分量图像组成，每种原色一幅分量图像。在RGB显示器中，这3幅图像在屏幕中最终混合成一幅彩色图像。通常，分量图像可以表示为一幅8比特图像，即RGB彩色像素可以表示为24比特深度。</p>
<p>通常 <em>全彩图像</em> 即指一幅24比特的RGB彩色图像，总共可表示2^24=16777216种色彩，对下下图的彩色立方体</p>
<img src="http://ohgqsah1g.bkt.clouddn.com/rgb-24bit-color-cube.png" class="rgb-24bit-color-cube" title="RGB 24比特彩色立方体">
<h2 id="分离色彩图像"><a href="#分离色彩图像" class="headerlink" title="分离色彩图像"></a>分离色彩图像</h2><p>任意一个像素点都可以分离出R、G、B对应色彩深度，而一副图像所有像素的R/G/B色彩深度集合，即构成了该图像的RGB分离色彩图像。</p>
<table>
<thead>
<tr>
<th><img src="http://ohgqsah1g.bkt.clouddn.com/origin-rgb.png" class="origin-rgb" title="原始图像"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="http://ohgqsah1g.bkt.clouddn.com/rgb-channel-r.png" class="origin-rgb" title="R通道分离图像"></td>
<td><img src="http://ohgqsah1g.bkt.clouddn.com/rgb-channel-g.png" class="origin-rgb" title="G通道分离图像"></td>
<td><img src="http://ohgqsah1g.bkt.clouddn.com/rgb-channel-b.png" class="origin-rgb" title="B通道分离图像"></td>
</tr>
</tbody>
</table>
<h1 id="CYM彩色模型"><a href="#CYM彩色模型" class="headerlink" title="CYM彩色模型"></a>CYM彩色模型</h1><h1 id="HSI彩色模型"><a href="#HSI彩色模型" class="headerlink" title="HSI彩色模型"></a>HSI彩色模型</h1><h1 id="YUV彩色模型"><a href="#YUV彩色模型" class="headerlink" title="YUV彩色模型"></a>YUV彩色模型</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;摘要： 介绍图片彩色模型的基本知识&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="数字图片处理" scheme="http://blog.snowwalf.com/categories/%E6%95%B0%E5%AD%97%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
    
    
      <category term="图片" scheme="http://blog.snowwalf.com/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>七牛云富媒体处理-图片处理-imageMogr2</title>
    <link href="http://blog.snowwalf.com/2016/12/20/%E4%B8%83%E7%89%9B%E4%BA%91%E5%AF%8C%E5%AA%92%E4%BD%93%E5%A4%84%E7%90%86-%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86-imageMogr2/"/>
    <id>http://blog.snowwalf.com/2016/12/20/七牛云富媒体处理-图片处理-imageMogr2/</id>
    <published>2016-12-20T14:58:07.000Z</published>
    <updated>2017-02-18T08:48:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>七牛云富媒体处理-图片处理命令imageMogr2使用示例和demo</em><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>七牛云的官方富媒体处理技术文档: </p>
<p><a href="http://developer.qiniu.com/code/v6/api/kodo-api/image/index.html" target="_blank" rel="external">http://developer.qiniu.com/code/v6/api/kodo-api/image/index.html</a></p>
<h1 id="缩放-thumbnail"><a href="#缩放-thumbnail" class="headerlink" title="缩放(thumbnail)"></a>缩放(thumbnail)</h1><p><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg" target="_blank" rel="external">http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg</a><br>原始图片信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;format&quot;: &quot;jpeg&quot;,</div><div class="line">    &quot;width&quot;: 640,</div><div class="line">    &quot;height&quot;: 427,</div><div class="line">    &quot;colorModel&quot;: &quot;ycbcr&quot;,</div><div class="line">    &quot;orientation&quot;: &quot;Top-left&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="按比例缩放"><a href="#按比例缩放" class="headerlink" title="按比例缩放"></a>按比例缩放</h2><h3 id="等比缩放-等比缩小75"><a href="#等比缩放-等比缩小75" class="headerlink" title="等比缩放(等比缩小75%)"></a>等比缩放(等比缩小75%)</h3><p><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/thumbnail/!75p" target="_blank" rel="external">http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/thumbnail/!75p</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/thumbnail-percentage-1.jpg?imageMogr2/thumbnail/!75p" class="thumbnail-75p" title="等比缩小75% imageMogr2/thumbnail/!75p"></p>
<h3 id="宽不变，高缩放-高缩小75"><a href="#宽不变，高缩放-高缩小75" class="headerlink" title="宽不变，高缩放(高缩小75%)"></a>宽不变，高缩放(高缩小75%)</h3><p><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/thumbnail/!x75p" target="_blank" rel="external">http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/thumbnail/!x75p</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/thumbnail-percentage-2.jpg?imageMogr2/thumbnail/!75p" class="thumbnail-x75p" title="高缩小75% imageMogr2/thumbnail/!x75p"></p>
<h3 id="高不变，宽缩放-宽缩小75"><a href="#高不变，宽缩放-宽缩小75" class="headerlink" title="高不变，宽缩放(宽缩小75%)"></a>高不变，宽缩放(宽缩小75%)</h3><p><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/thumbnail/!75px" target="_blank" rel="external">http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/thumbnail/!75px</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/thumbnail-percentage-3.jpg?imageMogr2/thumbnail/!75p" class="thumbnail-75px" title="宽缩小75% imageMogr2/thumbnail/!75px"></p>
<h1 id="裁剪-crop"><a href="#裁剪-crop" class="headerlink" title="裁剪(crop)"></a>裁剪(crop)</h1><h2 id="重心参数表"><a href="#重心参数表" class="headerlink" title="重心参数表"></a>重心参数表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NorthWest     |     North      |     NorthEast</div><div class="line">              |                |    </div><div class="line">              |                |    </div><div class="line">--------------+----------------+--------------</div><div class="line">              |                |    </div><div class="line">West          |     Center     |          East </div><div class="line">              |                |    </div><div class="line">--------------+----------------+--------------</div><div class="line">              |                |    </div><div class="line">              |                |    </div><div class="line">SouthWest     |     South      |     SouthEast</div></pre></td></tr></table></figure>
<h2 id="重心和X-Y轴正值方向"><a href="#重心和X-Y轴正值方向" class="headerlink" title="重心和X-Y轴正值方向"></a>重心和X-Y轴正值方向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">NorthWest     |     North      |     NorthEast</div><div class="line">   ------&gt;x   |      ------&gt;x  |     x&lt;------</div><div class="line">  |           |     |          |             |</div><div class="line">  |           |     |          |             |</div><div class="line">  |           |     |          |             |</div><div class="line">  v           |     v          |             v</div><div class="line"> y            |    y           |              y</div><div class="line">--------------+----------------+---------------</div><div class="line">West          |     Center     |          East </div><div class="line">   ------&gt;x   |      ------&gt;x  |     x&lt;------ </div><div class="line">  |           |     |          |             |</div><div class="line">  |           |     |          |             |</div><div class="line">  |           |     |          |             |</div><div class="line">  v           |     v          |             v</div><div class="line"> y            |    y           |              y</div><div class="line">--------------+----------------+---------------</div><div class="line"> y            |    y           |              y</div><div class="line">  ^           |     ^          |             ^</div><div class="line">  |           |     |          |             |</div><div class="line">  |           |     |          |             |</div><div class="line">  |           |     |          |             |</div><div class="line">   ------&gt;x   |      ------&gt;x  |     x&lt;------ </div><div class="line">SouthWest     |     South      |     SouthEast</div></pre></td></tr></table></figure>
<h2 id="裁剪偏移"><a href="#裁剪偏移" class="headerlink" title="裁剪偏移"></a>裁剪偏移</h2><h3 id="gravity-NorthWest-默认重心参数-，裁剪参数300x300"><a href="#gravity-NorthWest-默认重心参数-，裁剪参数300x300" class="headerlink" title="gravity=NorthWest (默认重心参数)，裁剪参数300x300"></a>gravity=NorthWest (默认重心参数)，裁剪参数300x300</h3><table>
<thead>
<tr>
<th style="text-align:center"><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/gravity/NorthWest/crop/!300x300-30-30" target="_blank" rel="external">x:-30 y:-30</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/northwest-300x300-30-30.jpg?imageMogr2/thumbnail/!75p" class="crop-northwest-300x300a0-30-30" title="imageMogr2/crop/!300x300-30-30"></th>
<th style="text-align:center"><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/gravity/NorthWest/crop/!300x300a0-30" target="_blank" rel="external">x:0 y:-30</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/northwest-300x300a0-30.jpg?imageMogr2/thumbnail/!75p" class="crop-northwest-300x300a0-30" title="imageMogr2/crop/!300x300a0-30"></th>
<th style="text-align:center"><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/gravity/NorthWest/crop/!300x300a30-30" target="_blank" rel="external">x:+30 y:-30</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/northwest-300x300a30-30.jpg?imageMogr2/thumbnail/!75p" class="crop-northwest-300x300a30-30" title="imageMogr2/crop/!300x300a30-30"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/gravity/NorthWest/crop/!300x300-30" target="_blank" rel="external">x:-30 y:0</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/northwest-300x300-30a0.jpg?imageMogr2/thumbnail/!75p" class="crop-northwest-300x300-30" title="imageMogr2/crop/!300x300-30"></td>
<td style="text-align:center"><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/gravity/NorthWest/crop/300x300" target="_blank" rel="external">x:0 y:0</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/northwest-300x300.jpg?imageMogr2/thumbnail/!50p" class="crop-northwest-300x300" title="imageMogr2/crop/300x300"></td>
<td style="text-align:center"><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/gravity/NorthWest/crop/!300x300a30" target="_blank" rel="external">x:+30 y:0</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/northwest-300x300a30.jpg?imageMogr2/thumbnail/!50p" class="crop-northwest-!300x300a30" title="imageMogr2/crop/!300x300a30"></td>
</tr>
<tr>
<td style="text-align:center"><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/gravity/NorthWest/crop/!300x300-30a30" target="_blank" rel="external">x:-30 y:+30</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/northwest-300x300-30a30.jpg?imageMogr2/thumbnail/!75p" class="crop-northwest-300x300-30a30" title="imageMogr2/crop/!300x300-30a30"></td>
<td style="text-align:center"><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/gravity/NorthWest/crop/!300x300a0a30" target="_blank" rel="external">x:0 y:+30</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/northwest-300x300a0a30.jpg?imageMogr2/thumbnail/!75p" class="crop-northwest-300x300a0a30" title="imageMogr2/crop/!300x300a0a30"></td>
<td style="text-align:center"><a href="http://78re52.com1.z0.glb.clouddn.com/resource/gogopher.jpg?imageMogr2/gravity/NorthWest/crop/!300x300a30a30" target="_blank" rel="external">x:+30 y:+30</a><br><img src="http://ohgqsah1g.bkt.clouddn.com/image/qiniu/img/imageMogr2/northwest-300x300a30a30.jpg?imageMogr2/thumbnail/!75p" class="crop-northwest-!300x300a30a30" title="imageMogr2/crop/!300x300a30a30"></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;七牛云富媒体处理-图片处理命令imageMogr2使用示例和demo&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="七牛" scheme="http://blog.snowwalf.com/categories/%E4%B8%83%E7%89%9B/"/>
    
    
      <category term="七牛" scheme="http://blog.snowwalf.com/tags/%E4%B8%83%E7%89%9B/"/>
    
      <category term="图片处理" scheme="http://blog.snowwalf.com/tags/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/"/>
    
      <category term="imageMogr2" scheme="http://blog.snowwalf.com/tags/imageMogr2/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg添加图片水印的畸变问题</title>
    <link href="http://blog.snowwalf.com/2016/12/12/ffmpeg-watermark/"/>
    <id>http://blog.snowwalf.com/2016/12/12/ffmpeg-watermark/</id>
    <published>2016-12-12T14:38:35.000Z</published>
    <updated>2016-12-15T14:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>摘要： 音视频添加图片水印时，SAR/DAR会造成图片水印随帧画面畸变。本文将分析畸变产生原因和探索解决方案</em><br><a id="more"></a></p>
<h1 id="PAR-SAR-DAR"><a href="#PAR-SAR-DAR" class="headerlink" title="PAR/SAR/DAR"></a>PAR/SAR/DAR</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>PAR(Pixel Aspect Ratio) 像素宽高比：单个像素的宽高比，通常该值为1，即正方形像素；若不为1，则为长方形像素。</li>
<li>SAR(Sample Aspect Ratio) 采样纵横比：视频横向对应的像素个数比上视频纵向的像素个数，即为我们通常提到的分辨率。</li>
<li>DAR(Display Aspect Ratio) 显示宽高比：终端显示时，播放画面的宽高比。</li>
</ul>
<h2 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h2><p><em><strong>SAR x PAR = DAR</strong></em></p>
<p>通过上述公式，可以根据SAR、PAR、DAR中的两个计算出另外一个</p>
<h2 id="ffmpeg中的分辨率、SAR、DAR"><a href="#ffmpeg中的分辨率、SAR、DAR" class="headerlink" title="ffmpeg中的分辨率、SAR、DAR"></a>ffmpeg中的分辨率、SAR、DAR</h2><p>先来看一个样例视频的<a href="http://media-resource.com0.z0.glb.qiniucdn.com/%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E8%A7%86%E9%A2%91%EF%BC%8D%E4%B8%89%E5%91%A8%E5%B9%B4.mp4?avinfo" target="_blank" rel="external">视频信息</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;width&quot;: 1920,</div><div class="line">&quot;height&quot;: 1080,</div><div class="line">&quot;coded_width&quot;: 1920,</div><div class="line">&quot;coded_height&quot;: 1088,</div><div class="line">&quot;has_b_frames&quot;: 2,</div><div class="line">&quot;sample_aspect_ratio&quot;: &quot;1:1&quot;,</div><div class="line">&quot;display_aspect_ratio&quot;: &quot;16:9&quot;,</div><div class="line">&quot;pix_fmt&quot;: &quot;yuv420p&quot;,</div></pre></td></tr></table></figure></p>
<p>分析上述样例视频的avinfo信息可知：</p>
<ul>
<li>分辨率=1920x108</li>
<li>sar=1:1</li>
<li>dar=16:9</li>
</ul>
<p>实际上，由于通常PAR=1:1，使得帧画面的宽高比=分辨率（即宽高像素数目）</p>
<p>此时，ffmpeg对于分辨率、sar、dar有如下公式：</p>
<p><em><strong>W/H * SAR = DAR</strong></em></p>
<p>上述样例视频，1920/1080 * (1/1) = 16:9</p>
<p>再看另外一个样例视频的<a href="http://ohgqsah1g.bkt.clouddn.com/water.mp4?avinfo" target="_blank" rel="external">视频信息</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;width&quot;: 480,</div><div class="line">&quot;height&quot;: 320,</div><div class="line">&quot;coded_width&quot;: 480,</div><div class="line">&quot;coded_height&quot;: 320,</div><div class="line">&quot;has_b_frames&quot;: 2,</div><div class="line">&quot;sample_aspect_ratio&quot;: &quot;32:27&quot;,</div><div class="line">&quot;display_aspect_ratio&quot;: &quot;16:9&quot;,</div><div class="line">&quot;pix_fmt&quot;: &quot;yuv420p&quot;,</div></pre></td></tr></table></figure></p>
<p>上述视频，480/320 * (32/27) = 16/9</p>
<h1 id="水印畸变"><a href="#水印畸变" class="headerlink" title="水印畸变"></a>水印畸变</h1><h2 id="播放形变"><a href="#播放形变" class="headerlink" title="播放形变"></a>播放形变</h2><p>一般视频终端播放是否发生形变，可以根据如下参数来判定：</p>
<ul>
<li>当SAR=1:1时，分辨率宽高比 = DAR，表示帧画面在终端播放时不会产生形变</li>
<li>当SAR!=1:1时，分辨率宽高比 != DAR，表示帧画面在终端播放时会产生形变</li>
</ul>
<h2 id="终端播放形变方式"><a href="#终端播放形变方式" class="headerlink" title="终端播放形变方式"></a>终端播放形变方式</h2><p>形变方式通常可以分为三种：</p>
<ol>
<li>保持短边不变，长边缩放</li>
<li>保持长边不变，短边缩放</li>
<li>长边短边同时缩放</li>
</ol>
<p>若以样例视频二为例，上述三种形变方式可得：</p>
<ol>
<li>原始画面480x320，短边保持不变，此时H=320,DAR=16/9，得W=320/9*16=569,即长边缩放比为569/480=1.185</li>
<li>原始画面480x320，长边边保持不变，此时W=480,DAR=16/9,得H=480/16*9=270，即短边的缩放比为270/320=0.84375</li>
<li>根据播放器实际情况发生变化</li>
</ol>
<h2 id="播放形变带来的水印形变"><a href="#播放形变带来的水印形变" class="headerlink" title="播放形变带来的水印形变"></a>播放形变带来的水印形变</h2><p>图片水印通常直接合成在原始帧画面中，故播放端的形变会连带造成水印产生畸变</p>
<p>以上述形变方式1为例，假设为原始视频打上一个40x40的方形水印，在终端播放时，长边会进行1.185倍的缩放，故实际水印显示大小约为47x40，畸变成为一个长方形水印</p>
<h1 id="图片水印畸变的解决方案"><a href="#图片水印畸变的解决方案" class="headerlink" title="图片水印畸变的解决方案"></a>图片水印畸变的解决方案</h1><p>在实际的生产应用中，有些需求水印要保持原始的长宽比，不能发生畸变，此时需要对图片水印畸变进行修正</p>
<h2 id="反向修正水印图片"><a href="#反向修正水印图片" class="headerlink" title="反向修正水印图片"></a>反向修正水印图片</h2><p>顾名思义，由于畸变发生在播放终端，故可以预测畸变行为，预先将水印图片变形后再压入原始帧画面，预变形图片会按预期畸变后恢复正常</p>
<p>以样例视频二为例，添加40x40的水印，假设采用第一种形变方式：</p>
<ol>
<li>计算可知，原始帧画面横边缩放比为1.185</li>
<li>反向压缩水印视频W=40/1.185=34，即将水印图片压缩成为34x40</li>
<li>终端播放，根据第一种形变方式，长边缩放，图片水印W’=34*1.185=40，即恢复到40x40的水印图片</li>
</ol>
<p>第二种形变方式处理方式相同</p>
<p><font color="red">上述方式存在问题</font>：</p>
<p>如果预测的形变方式与终端实际形变方式不同，可能造成水印图片等比缩放</p>
<p>比如，预测第一种形变方式，实际终端播放采用第二中形变方式：</p>
<ol>
<li>水印图片压缩后34x40</li>
<li>终端播放时，短边缩放比为0.84375，播放时水印高H=40*0.84375=34，即水印图片实际播放大小为34x34，即实际水印等比缩放了0.84375倍</li>
</ol>
<p>而若是终端播放采用第三种形变方式，则水印图片畸变不可预测，故修正后仍可能畸变</p>
<p><em>（由于播放形变取决的终端行为，故对水印畸变的情况并不能准确预测，不同的畸变模式的修正方式不一样，博主仅能据工作中的实际处理情况给出一些解决方案，欢迎大家指正）</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;摘要： 音视频添加图片水印时，SAR/DAR会造成图片水印随帧画面畸变。本文将分析畸变产生原因和探索解决方案&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="音视频处理" scheme="http://blog.snowwalf.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
    
      <category term="ffmpeg" scheme="http://blog.snowwalf.com/tags/ffmpeg/"/>
    
      <category term="音视频" scheme="http://blog.snowwalf.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="视频水印" scheme="http://blog.snowwalf.com/tags/%E8%A7%86%E9%A2%91%E6%B0%B4%E5%8D%B0/"/>
    
  </entry>
  
  <entry>
    <title>CPU高速缓存行对齐</title>
    <link href="http://blog.snowwalf.com/2011/09/17/CPU%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%A1%8C%E5%AF%B9%E9%BD%90/"/>
    <id>http://blog.snowwalf.com/2011/09/17/CPU高速缓存行对齐/</id>
    <published>2011-09-17T01:48:00.000Z</published>
    <updated>2016-12-15T14:38:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>摘要：本文介绍了CPU高速缓存以及高速缓存行对齐，探索编程中对于行对齐的优化</em><br><a id="more"></a></p>
<h1 id="CPU高速缓存"><a href="#CPU高速缓存" class="headerlink" title="CPU高速缓存"></a>CPU高速缓存</h1><p>CPU的高速缓存一般分为一级缓存和二级缓存，现今更多的CPU更是提供了三级缓存。</p>
<p>CPU在运行时首先从一级缓存读取数据，如果读取失败则会从二级缓存读取数据，如果仍然失败则再从内存中存读取数据。而CPU从一级缓存或二级缓存或主内存中最终读取到数据所耗费的时钟周期差距是非常之大的。因此高速缓存的容量和速度直接影响到CPU的工作性能。</p>
<p>一级缓存都内置在CPU内部并与CPU同速运行，可以有效的提高CPU的运行效率。一级缓存越大，CPU的运行效率往往越高。</p>
<h1 id="高速缓存行对齐"><a href="#高速缓存行对齐" class="headerlink" title="高速缓存行对齐"></a>高速缓存行对齐</h1><h2 id="单CPU缓存行对齐"><a href="#单CPU缓存行对齐" class="headerlink" title="单CPU缓存行对齐"></a>单CPU缓存行对齐</h2><p>一级缓存又分为数据缓存和指令缓存，他们都由高速缓存行组成，对于X86架构的CPU来说，高速缓存行一般是32个字节，早期的CPU大约只有512行高速缓存行，也就是说约16k的一级缓存。而现在的CPU一般都是32K以上的一级缓存。</p>
<p>当CPU需要读取一个变量时，该变量所在的以32字节分组的内存数据将被一同读入高速缓存行，所以，对于性能要求严格的程序来说，充分利用高速缓存行的优势非常重要。一次性将访问频繁的32字节数据对齐后读入高速缓存中，减少CPU高级缓存与低级缓存、内存的数据交换。</p>
<h2 id="多CPU缓存行对齐"><a href="#多CPU缓存行对齐" class="headerlink" title="多CPU缓存行对齐"></a>多CPU缓存行对齐</h2><p>对于多CPU的计算机，情况却又不一样了：</p>
<ol>
<li>CPU1读取了一个字节，以及它和它相邻的字节被读入 CPU1 的高速缓存。</li>
<li>CPU2做了上面同样的工作。这样 CPU1，CPU2 的高速缓存拥有同样的数据。</li>
<li>CPU1修改了那个字节，被修改后，那个字节被放回CPU1的高速缓存行。但是该信息并没有被写入RAM 。</li>
<li>CPU2访问该字节，但由于CPU1并未将数据写入RAM ，导致了数据不同步。</li>
</ol>
<p>当一个CPU修改高速缓存行中的字节时，计算机中的其它CPU会被通知，它们的高速缓存将视为无效。于是，在上面的情况下， CPU2发现自己的高速缓存中数据已无效， CPU1将立即把自己的数据写回RAM，然后CPU2重新读取该数据。可以看出，高速缓存行在多处理器上会导致一些不利。</p>
<p>从上面的情况可以看出，在设计数据结构的时候，应该尽量将只读数据与读写数据分开，并具尽量将同一时间访问的数据组合在一起。这样CPU能一次将需要的数据读入。</p>
<h1 id="编程中对缓存行对齐的优化"><a href="#编程中对缓存行对齐的优化" class="headerlink" title="编程中对缓存行对齐的优化"></a>编程中对缓存行对齐的优化</h1><p>假设有如下结构体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Struct __a</div><div class="line">&#123;</div><div class="line">    Int id; // 不易变</div><div class="line">    Int factor;// 易变</div><div class="line">    Char name[64];// 不易变</div><div class="line">    Int value;// 易变</div><div class="line">&#125; ；</div></pre></td></tr></table></figure></p>
<p>根据上述行对齐原来，这样的数据结构在X86架构下，执行是不利的</p>
<p>可以做如下调整，保证读写分离行对齐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Struct __a</div><div class="line">&#123;</div><div class="line">    Int id; // 不易变</div><div class="line">    Char name[64];// 不易变</div><div class="line">    Char __Align[32 – sizeof(int)+sizeof(name)*sizeof(name[0])%32]</div><div class="line">    Int factor;// 易变</div><div class="line">    Int value;// 易变</div><div class="line">    Char __Align2[32 –2* sizeof(int)%32]</div><div class="line">&#125; ；</div></pre></td></tr></table></figure></p>
<ul>
<li>32 – sizeof(int)+sizeof(name)*sizeof(name[0])%32</li>
<li>32 表示 X86 架构中缓存中，高速缓存行为 32字节 大小。 __Align 用于显式对齐。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;摘要：本文介绍了CPU高速缓存以及高速缓存行对齐，探索编程中对于行对齐的优化&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux内核" scheme="http://blog.snowwalf.com/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="linux" scheme="http://blog.snowwalf.com/tags/linux/"/>
    
      <category term="x86" scheme="http://blog.snowwalf.com/tags/x86/"/>
    
      <category term="数据结构" scheme="http://blog.snowwalf.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>bochs+gdb源码级调试linux0.12内核测试环境构建</title>
    <link href="http://blog.snowwalf.com/2011/05/31/bochs-gdb-linux0-12-debug/"/>
    <id>http://blog.snowwalf.com/2011/05/31/bochs-gdb-linux0-12-debug/</id>
    <published>2011-05-31T06:12:00.000Z</published>
    <updated>2016-12-14T16:18:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>bochs+gdb搭建linux0.12内核源码调试环境</em><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前都是用的bochs自带的debug功能，但是linux内核大部分都是用C语vv言来实现的，若仅通过反汇编的汇编来学习，太累了。。。</p>
<p>所以今天花了一个上午的时间，搭建起了bochs+gbd的联调环境。</p>
<h1 id="安装bochs"><a href="#安装bochs" class="headerlink" title="安装bochs"></a>安装bochs</h1><p>首先还是要安装bochs，仍然是推荐使用最新的版本（2.4.6），如果使用像2.3.6等老版本，也许会导致后面与gdb无法远程连接（NND，就是这个恶心的问题浪费了我几个小时。。。）</p>
<p>linux上还是要从bochs的源码编译开始安装，bin文件安装的版本无法提供调试功能。</p>
<p>配置bochs源码时，输入命令 ./configure –enable-gdb-stub，然后使用make和sudo make install命令完成安装。</p>
<p>安装时可能会遇到X windows库不全的情况，可以通过apt-get安装xorg-dev解决。</p>
<p>如果是从source code进行编译安装时，有可能会用到的两个组件分别是build-essential和libxrandr-dev，各自作用请自行搜索～</p>
<h1 id="配置bochs"><a href="#配置bochs" class="headerlink" title="配置bochs"></a>配置bochs</h1><p>配置bochs虚拟机环境需要一个.bxrc文件和生产一个根文件系统镜像文件，建议直接到oldlinux上下载一个linux-0.11-gdb-rh9-050619.tar.gz，其中已经包含了配置好的这两个文件，另外在linux文件夹下有linux0.11的源码。</p>
<p>.bxrc文件中主要是添加了一条调试信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gdbstub: enable=1, port=1234, text_base=0, data_base=0, bss_base=0</div></pre></td></tr></table></figure></p>
<p>另外，这个bxrc文件中需要稍稍修改一些东西：</p>
<ol>
<li><p>romimage: file=$BXSHARE/BIOS-bochs-latest,  address=0xf0000 改成 romimage: file=$BXSHARE/BIOS-bochs-latest</p>
</li>
<li><p>floppy_command_delay: 50000 改成 #floppy_command_delay: 50000</p>
</li>
<li><p>3.ips: 4000000 改成 cpu: count=1, ips=4000000</p>
</li>
</ol>
<h1 id="使用bochs进行联机调试"><a href="#使用bochs进行联机调试" class="headerlink" title="使用bochs进行联机调试"></a>使用bochs进行联机调试</h1><ol>
<li>打开两个终端。</li>
<li>一个终端进入到linux-gdb-rh9/，运行程序”./run”，此时窗口显示等待信息“wait for gdb connection on localhost:1234”</li>
<li>另一个终端进入linux-gdb-rh9/linux/，运行 gdb tools/system</li>
<li>在gdb窗口中输入b main（在main函数处下断）</li>
<li>输入target remote localhost:1234 ，连接到bochs虚拟机上</li>
<li>输入c，让程序持续运行，直到终端在main函数中</li>
<li>可以开始使用gdb进行源码调试了^_^</li>
</ol>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li>早期源码默认的汇编编译器为gas，链接器为gld，所以在Makefile文件中显示声明as=gas ld=gld。而在ubuntu 11.04中，gcc早已成为默认的编译器了，所以如果是另外下载的源码，需要将Makefile中的as=gas ld=gld改成 as=as， ld=ld</li>
</ul>
<hr>
<p>先写到这，有在想到的继续啊~~~^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;bochs+gdb搭建linux0.12内核源码调试环境&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux内核" scheme="http://blog.snowwalf.com/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="linux" scheme="http://blog.snowwalf.com/tags/linux/"/>
    
      <category term="bochs" scheme="http://blog.snowwalf.com/tags/bochs/"/>
    
  </entry>
  
  <entry>
    <title>bochs的使用心得</title>
    <link href="http://blog.snowwalf.com/2011/05/28/bochs-experience/"/>
    <id>http://blog.snowwalf.com/2011/05/28/bochs-experience/</id>
    <published>2011-05-28T08:09:00.000Z</published>
    <updated>2016-12-14T16:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>bochs的使用和调试 linux内核<br><a id="more"></a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>bochs的简介吧，来自度娘：</p>
<blockquote>
<p>Bochs是一个x86硬件平台的开源模拟器。它可以模拟各种硬件的配置。Bochs模拟的是整个PC平台，包括I/O设备、内存和BIOS。更为有趣的是，甚至可以不使用PC硬件来运行Bochs。事实上，它可以在任何编译运行Bochs的平台上模拟x86硬件。通过改变配置，可以指定使用的CPU(386、486或者586)，以及内存大小等。一句话，Bochs是电脑里的“PC”。根据需要，Bochs还可以模拟多台PC，此外，它甚至还有自己的电源按钮。</p>
</blockquote>
<p>用下来感觉bochs非常小巧，相比于VM功能上并不相差很多，而且对于一些比较“古董”的硬件接口支持比较好，通过.bxrc文件能够很方便的生产和配置硬件。bochs内嵌的调试器比较好用，可以从虚拟机通电加载ROM BIOS起开始调试，对于了解操作系统的详细原理还是很有帮助的。就是没有图形化得调试界面比较蛋疼。。。用惯了VS,Windbg的人有点压力大。。。不过慢慢用就习惯了。</p>
<h1 id="获取bochs"><a href="#获取bochs" class="headerlink" title="获取bochs"></a>获取bochs</h1><p>可以去Sourceforge上下载src或者bin： <a href="http://bochs.sourceforge.net/" target="_blank" rel="external">http://bochs.sourceforge.net/</a>  （linux上建议还是从src开始编译，bin版本中往往不带有bochsdbg这个调试程序。。。windows的话可以直接用.exe的，安装完后是包含dbg程序的，所以我还是用的windows版^_^）</p>
<p>也可以去oldlinux上下载： <a href="http://oldlinux.org/Linux.old/bochs/" target="_blank" rel="external">http://oldlinux.org/Linux.old/bochs/</a><br>赵炯老师的书上建议调试Linux0.12使用的是bochs2.3.6，但经我实测发现最新的版本（现在是2.4.6）也是也是兼容的，而且2.4.6的调试指令相比老版本有不少的改进，所以还是建议使用最新的版本。</p>
<h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>安装和配置比较简单，windows的话只要下一步就OK；</p>
<p>linux上编译src需要在编译时设置编译选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/opt/bochs/debug --enable-plugins --enable-debugger --enable- disasm</div></pre></td></tr></table></figure>
<ul>
<li>–prefix=/opt/bochs/debug 软件将被安装到哪个目录下</li>
<li>–enable-plugins 是必须要的</li>
<li>–enable-debugger 是打开bochs的自带调试器</li>
<li>–enbale-disasm 允许反汇编</li>
</ul>
<h1 id="调试指令"><a href="#调试指令" class="headerlink" title="调试指令"></a>调试指令</h1><p>再来些bochsdbg的调试指令吧，网上搜的有些指令因为版本问题并不能使用（我用的是2.4.6）：</p>
<h2 id="普通指令组"><a href="#普通指令组" class="headerlink" title="普通指令组"></a>普通指令组</h2><table>
<thead>
<tr>
<th>指令格式</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>b addr</td>
<td style="text-align:left">在物理地址处设置断点 addr为物理内存地址，不加段基址</td>
</tr>
<tr>
<td>lb addr</td>
<td style="text-align:left">在线性地址处设置断点  addr为线性物理地址，不加基址</td>
</tr>
<tr>
<td>vb addr</td>
<td style="text-align:left">在虚拟地址上设置断点 addr为段基址：偏移地址， cs段</td>
</tr>
<tr>
<td>c</td>
<td style="text-align:left">继续执行知道遇到断点</td>
</tr>
<tr>
<td>n</td>
<td style="text-align:left">单步执行 跳过子程序和int中断程序</td>
</tr>
<tr>
<td>s</td>
<td style="text-align:left">单步执行</td>
</tr>
<tr>
<td>s num</td>
<td style="text-align:left">执行n步</td>
</tr>
<tr>
<td>dump_cpu</td>
<td style="text-align:left">查看寄存器信息（实测下来这个指令好像不好使）</td>
</tr>
<tr>
<td>x /nuf addr</td>
<td style="text-align:left">显示指定内存地址的数据，addr可以是线性的内存地址，也可以是虚址 格式是基址：偏移或者基址寄存器：偏移<br>n 显示的数据长度<br>u 数据单元大小 b,h,w,g分别对应1,2,4,8字节<br>f 数据显示格式 x,d,u,o,t,c分别对应十六进制、十进制、无符号十进制、八进制、二进制、字符串</td>
</tr>
<tr>
<td>u [/count] start end</td>
<td style="text-align:left">反汇编一段线性内存(作用与上面的一样)<br>(count 参数指明要反汇编的指令条数 ,例子：u /5 –反汇编从当前地址开始的5条指令)</td>
</tr>
</tbody>
</table>
<h2 id="info指令组"><a href="#info指令组" class="headerlink" title="info指令组"></a>info指令组</h2><table>
<thead>
<tr>
<th>指令格式</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>info b</td>
<td style="text-align:left">展示当前的断点状态信息</td>
</tr>
<tr>
<td>info dirty</td>
<td style="text-align:left">展示自从上次显示以来物理内存中的脏页（被写的页）</td>
</tr>
<tr>
<td>info program</td>
<td style="text-align:left">展示程序的执行状态（无法使用！）</td>
</tr>
<tr>
<td>info r/reg/rigisters</td>
<td style="text-align:left">展示寄存器内容</td>
</tr>
<tr>
<td>info cpu</td>
<td style="text-align:left">展示CPU寄存器内容</td>
</tr>
<tr>
<td>info fpu</td>
<td style="text-align:left">展示FPU寄存器的状态</td>
</tr>
<tr>
<td>info idt</td>
<td style="text-align:left">展示中断描述表</td>
</tr>
<tr>
<td>info ivt</td>
<td style="text-align:left">展示中断向量表(保护模式下无效)</td>
</tr>
<tr>
<td>info gdt</td>
<td style="text-align:left">展示全局描述表</td>
</tr>
<tr>
<td>info tss</td>
<td style="text-align:left">展示当前的任务状态段</td>
</tr>
<tr>
<td>info cr</td>
<td style="text-align:left">展示CR0-CR4寄存器状态 （无法使用）</td>
</tr>
<tr>
<td>info flags</td>
<td style="text-align:left">展示标志寄存器   （无法使用）</td>
</tr>
</tbody>
</table>
<h2 id="寄存器查询"><a href="#寄存器查询" class="headerlink" title="寄存器查询"></a>寄存器查询</h2><table>
<thead>
<tr>
<th>指令格式</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td style="text-align:left">查看通用寄存器</td>
</tr>
<tr>
<td>sreg</td>
<td style="text-align:left">查看段寄存器（es,cs,gs,ss,fs,ds以及idt,gdt,ldt,tr）</td>
</tr>
<tr>
<td>creg</td>
<td style="text-align:left">查看控制寄存器（cr0，cr1，cr2，cr3）</td>
</tr>
<tr>
<td>dreg</td>
<td style="text-align:left">查看调试寄存器（dr0-dr7）</td>
</tr>
</tbody>
</table>
<p>这里再插一句，标志寄存器的查看方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eflags 0x00000002: id vip vif ac vm rf nt IOPL=0 of df if tf sf zf af pf cf    （均未置位）</div><div class="line"></div><div class="line">eflags 0x00000046: id vip vif ac vm rf nt IOPL=0 of df if tf sf ZF af PF cf （ZF,PF置位）</div></pre></td></tr></table></figure></p>
<p>0x00000002是标志寄存器的实际数值，后面的zf，sf等为标志位，小写时标志位未置位，大写为已置位。</p>
<h1 id="在linux0-12系统上编译0-12内核："><a href="#在linux0-12系统上编译0-12内核：" class="headerlink" title="在linux0.12系统上编译0.12内核："></a>在linux0.12系统上编译0.12内核：</h1><ul>
<li><p>从前文下载的根文件系统rootimage-0.12上已经包含了0.12内核的源码，位于/usr/src/linux。</p>
</li>
<li><p>使用make命令编译源码，生成引导区启动镜像文件Image。</p>
</li>
<li><p>通过命令dd bs=8192 if=Image of=/dev/fd0 将生成的镜像输出到虚拟软盘文件bootimage-0.12-hd上（记得先备份一个啊！），再次启动bochs，即可由新的镜像引导启动了。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bochs的使用和调试 linux内核&lt;br&gt;
    
    </summary>
    
      <category term="Linux内核" scheme="http://blog.snowwalf.com/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="linux" scheme="http://blog.snowwalf.com/tags/linux/"/>
    
      <category term="bochs" scheme="http://blog.snowwalf.com/tags/bochs/"/>
    
      <category term="调试" scheme="http://blog.snowwalf.com/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>A20地址线的一点理解</title>
    <link href="http://blog.snowwalf.com/2011/05/27/a20-bus/"/>
    <id>http://blog.snowwalf.com/2011/05/27/a20-bus/</id>
    <published>2011-05-27T11:30:00.000Z</published>
    <updated>2016-12-14T16:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>A20地址线 Linux内核实现及系统启动引导</em><br><a id="more"></a></p>
<h2 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h2><p>先来看看A20地址线的由来和历史遗留问题（纯搬运）：</p>
<blockquote>
<p>   1981年8月，IBM公司最初推出的个人计算机IBM PC使用的CPU是Intel 8088。在该微机中地址线只有20根(A0 – A19)。在当时内存RAM只有几百KB或不到1MB时，20根地址线已足够用来寻址这些内存。其所能寻址的最高地址是0xffff:0xffff，也即0x10ffef。对于超出0x100000(1MB)的寻址地址将默认地环绕到0x0ffef。当IBM公司于1985年引入AT机时，使用的是Intel 80286 CPU，具有24根地址线，最高可寻址16MB，并且有一个与8088完全兼容的实模式运行方式。然而，在寻址值超过1MB时它却不能象8088那样实现地址寻址的环绕。但是当时已经有一些程序是利用这种地址环绕机制进行工作的。为了实现完全的兼容性，IBM公司发明了使用一个开关来开启或禁止0x100000地址比特位。由于在当时的8042键盘控制器上恰好有空闲的端口引脚（输出端口P2，引脚P21），于是便使用了该引脚来作为与门控制这个地址比特位。该信号即被称为A20。如果A20为零，则比特20及以上地址都被清除。从而实现了兼容性。</p>
</blockquote>
<p>由于在机器启动时，默认条件下，A20地址线是禁止的，所以操作系统必须使用适当的方法来开启它。但是由于各种兼容机所使用的芯片集不同，要做到这一点却是非常的麻烦。因此通常要在几种控制方法中选择。</p>
<h2 id="A20地址线的控制"><a href="#A20地址线的控制" class="headerlink" title="A20地址线的控制"></a>A20地址线的控制</h2><p>对A20信号线进行控制的常用方法是通过设置键盘控制器的端口值。下面引用一段linux0.11的源码（setup.s）:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">	call 	empty_8042</div><div class="line"> </div><div class="line">	mov	al,#0xd1</div><div class="line">	out	#0x64,al</div><div class="line">	call	empty_8042</div><div class="line">	mov	al,#0xdf</div><div class="line">	out	#0x60,al</div><div class="line">	call	empty_8042</div><div class="line"> </div><div class="line">...</div><div class="line"> </div><div class="line">empty_8042:</div><div class="line">	.word 0x00eb,0x00eb</div><div class="line">	in 	al,#0x64</div><div class="line">	test	al,#2</div><div class="line">	jnz	empty_8042</div><div class="line">	ret</div></pre></td></tr></table></figure></p>
<p>贴一下啊head.s中的代码(这里转成Intel汇编格式，源码是AT&amp;A汇编，看着蛋疼。。)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	xor eax,eax</div><div class="line">l:</div><div class="line">	inc eax</div><div class="line">	mov [0x000000],eax;</div><div class="line">	cmp [0x100000],eax;</div><div class="line">	je lb</div></pre></td></tr></table></figure></p>
<p>向0x000000字节处数据改为1，查看0x100000处数据是否同时变成了1，若是则A20地址线没用开启；否则开启成功。</p>
<h2 id="Intel-8042芯片"><a href="#Intel-8042芯片" class="headerlink" title="Intel 8042芯片"></a>Intel 8042芯片</h2><p>解释一下Intel 8042芯片（又是搬运。。。）：</p>
<blockquote>
<p>   ntel8024是intel公司的一款键盘控制器芯片,它为x86系统中的标准配置.虽然名为键盘控制器,但是鼠标也是由其控制的.<br>    键盘通常使用IRQ1.鼠标通常使用IRQ12.IRQ1和IRQ12都是连接在键盘控制器上的.对应intel8042的两个端口.</p>
</blockquote>
<pre><code>配给键盘控制器的I/O端口有四个,分别是0x60~0x64.在大部分情况中,只会使用到0x60和0x64.其余0x61~0x64的存在主要是为了兼容XT.可以将0x64看做是状态寄存器.0x60看成是数据寄存器.有时在给键盘控制器下指令的时候,这两个端口都要用到.两者配合来达到下指令与参数的目的.
</code></pre><h2 id="向i8042发送命令"><a href="#向i8042发送命令" class="headerlink" title="向i8042发送命令:"></a>向i8042发送命令:</h2><ol>
<li>我们需要先把命令发送到0x64端口，</li>
<li>然后紧接着把这个命令的参数发送到0x60端口，</li>
<li>然后我们可以通过读0x60端口，获得i8042返回给我们的数据。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;A20地址线 Linux内核实现及系统启动引导&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux内核" scheme="http://blog.snowwalf.com/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="linux" scheme="http://blog.snowwalf.com/tags/linux/"/>
    
  </entry>
  
</feed>
