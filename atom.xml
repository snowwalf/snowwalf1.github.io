<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮生半日闲</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.snowwalf.com/"/>
  <updated>2016-12-13T14:44:34.000Z</updated>
  <id>http://blog.snowwalf.com/</id>
  
  <author>
    <name>snowwalf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello world</title>
    <link href="http://blog.snowwalf.com/2016/12/13/hello-world/"/>
    <id>http://blog.snowwalf.com/2016/12/13/hello-world/</id>
    <published>2016-12-12T16:57:34.000Z</published>
    <updated>2016-12-13T14:44:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="施工中，敬请期待"><a href="#施工中，敬请期待" class="headerlink" title="施工中，敬请期待"></a>施工中，敬请期待</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;施工中，敬请期待&quot;&gt;&lt;a href=&quot;#施工中，敬请期待&quot; class=&quot;headerlink&quot; title=&quot;施工中，敬请期待&quot;&gt;&lt;/a&gt;施工中，敬请期待&lt;/h2&gt;
    
    </summary>
    
      <category term="音视频处理" scheme="http://blog.snowwalf.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
    
      <category term="ffmpeg" scheme="http://blog.snowwalf.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>A20地址线的一点理解</title>
    <link href="http://blog.snowwalf.com/2011/05/27/A20%E5%9C%B0%E5%9D%80%E7%BA%BF%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/"/>
    <id>http://blog.snowwalf.com/2011/05/27/A20地址线的一点理解/</id>
    <published>2011-05-27T11:30:00.000Z</published>
    <updated>2016-12-13T15:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>A20地址线 Linux内核实现及系统启动引导</em><br><a id="more"></a></p>
<h2 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h2><p>先来看看A20地址线的由来和历史遗留问题（纯搬运）：</p>
<blockquote>
<p>   1981年8月，IBM公司最初推出的个人计算机IBM PC使用的CPU是Intel 8088。在该微机中地址线只有20根(A0 – A19)。在当时内存RAM只有几百KB或不到1MB时，20根地址线已足够用来寻址这些内存。其所能寻址的最高地址是0xffff:0xffff，也即0x10ffef。对于超出0x100000(1MB)的寻址地址将默认地环绕到0x0ffef。当IBM公司于1985年引入AT机时，使用的是Intel 80286 CPU，具有24根地址线，最高可寻址16MB，并且有一个与8088完全兼容的实模式运行方式。然而，在寻址值超过1MB时它却不能象8088那样实现地址寻址的环绕。但是当时已经有一些程序是利用这种地址环绕机制进行工作的。为了实现完全的兼容性，IBM公司发明了使用一个开关来开启或禁止0x100000地址比特位。由于在当时的8042键盘控制器上恰好有空闲的端口引脚（输出端口P2，引脚P21），于是便使用了该引脚来作为与门控制这个地址比特位。该信号即被称为A20。如果A20为零，则比特20及以上地址都被清除。从而实现了兼容性。</p>
</blockquote>
<p>由于在机器启动时，默认条件下，A20地址线是禁止的，所以操作系统必须使用适当的方法来开启它。但是由于各种兼容机所使用的芯片集不同，要做到这一点却是非常的麻烦。因此通常要在几种控制方法中选择。</p>
<h2 id="A20地址线的控制"><a href="#A20地址线的控制" class="headerlink" title="A20地址线的控制"></a>A20地址线的控制</h2><p>对A20信号线进行控制的常用方法是通过设置键盘控制器的端口值。下面引用一段linux0.11的源码（setup.s）:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">	call 	empty_8042</div><div class="line"> </div><div class="line">	mov	al,#0xd1</div><div class="line">	out	#0x64,al</div><div class="line">	call	empty_8042</div><div class="line">	mov	al,#0xdf</div><div class="line">	out	#0x60,al</div><div class="line">	call	empty_8042</div><div class="line"> </div><div class="line">...</div><div class="line"> </div><div class="line">empty_8042:</div><div class="line">	.word 0x00eb,0x00eb</div><div class="line">	in 	al,#0x64</div><div class="line">	test	al,#2</div><div class="line">	jnz	empty_8042</div><div class="line">	ret</div></pre></td></tr></table></figure></p>
<p>贴一下啊head.s中的代码(这里转成Intel汇编格式，源码是AT&amp;A汇编，看着蛋疼。。)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	xor eax,eax</div><div class="line">l:</div><div class="line">	inc eax</div><div class="line">	mov [0x000000],eax;</div><div class="line">	cmp [0x100000],eax;</div><div class="line">	je lb</div></pre></td></tr></table></figure></p>
<p>向0x000000字节处数据改为1，查看0x100000处数据是否同时变成了1，若是则A20地址线没用开启；否则开启成功。</p>
<h2 id="Intel-8042芯片"><a href="#Intel-8042芯片" class="headerlink" title="Intel 8042芯片"></a>Intel 8042芯片</h2><p>解释一下Intel 8042芯片（又是搬运。。。）：</p>
<blockquote>
<p>   ntel8024是intel公司的一款键盘控制器芯片,它为x86系统中的标准配置.虽然名为键盘控制器,但是鼠标也是由其控制的.<br>    键盘通常使用IRQ1.鼠标通常使用IRQ12.IRQ1和IRQ12都是连接在键盘控制器上的.对应intel8042的两个端口.</p>
</blockquote>
<pre><code>配给键盘控制器的I/O端口有四个,分别是0x60~0x64.在大部分情况中,只会使用到0x60和0x64.其余0x61~0x64的存在主要是为了兼容XT.可以将0x64看做是状态寄存器.0x60看成是数据寄存器.有时在给键盘控制器下指令的时候,这两个端口都要用到.两者配合来达到下指令与参数的目的.
</code></pre><h2 id="向i8042发送命令"><a href="#向i8042发送命令" class="headerlink" title="向i8042发送命令:"></a>向i8042发送命令:</h2><ol>
<li>我们需要先把命令发送到0x64端口，</li>
<li>然后紧接着把这个命令的参数发送到0x60端口，</li>
<li>然后我们可以通过读0x60端口，获得i8042返回给我们的数据。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;A20地址线 Linux内核实现及系统启动引导&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux内核" scheme="http://blog.snowwalf.com/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="linux" scheme="http://blog.snowwalf.com/tags/linux/"/>
    
  </entry>
  
</feed>
