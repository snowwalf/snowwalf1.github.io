<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>浮生半日闲</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.snowwalf.com/"/>
  <updated>2016-12-15T14:10:24.000Z</updated>
  <id>http://blog.snowwalf.com/</id>
  
  <author>
    <name>snowwalf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ffmpeg添加图片水印的畸变问题</title>
    <link href="http://blog.snowwalf.com/2016/12/12/ffmpeg-watermark/"/>
    <id>http://blog.snowwalf.com/2016/12/12/ffmpeg-watermark/</id>
    <published>2016-12-12T14:38:35.000Z</published>
    <updated>2016-12-15T14:10:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>摘要： 音视频添加图片水印时，SAR/DAR会造成图片水印随帧画面畸变。本文将分析畸变产生原因和探索解决方案</em><br><a id="more"></a></p>
<h1 id="PAR-SAR-DAR"><a href="#PAR-SAR-DAR" class="headerlink" title="PAR/SAR/DAR"></a>PAR/SAR/DAR</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>PAR(Pixel Aspect Ratio) 像素宽高比：单个像素的宽高比，通常该值为1，即正方形像素；若不为1，则为长方形像素。</li>
<li>SAR(Sample Aspect Ratio) 采样纵横比：视频横向对应的像素个数比上视频纵向的像素个数，即为我们通常提到的分辨率。</li>
<li>DAR(Display Aspect Ratio) 显示宽高比：终端显示时，播放画面的宽高比。</li>
</ul>
<h2 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h2><p><em><strong>SAR x PAR = DAR</strong></em></p>
<p>通过上述公式，可以根据SAR、PAR、DAR中的两个计算出另外一个</p>
<h2 id="ffmpeg中的分辨率、SAR、DAR"><a href="#ffmpeg中的分辨率、SAR、DAR" class="headerlink" title="ffmpeg中的分辨率、SAR、DAR"></a>ffmpeg中的分辨率、SAR、DAR</h2><p>先来看一个样例视频的<a href="http://media-resource.com0.z0.glb.qiniucdn.com/%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E8%A7%86%E9%A2%91%EF%BC%8D%E4%B8%89%E5%91%A8%E5%B9%B4.mp4?avinfo" target="_blank" rel="external">视频信息</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;width&quot;: 1920,</div><div class="line">&quot;height&quot;: 1080,</div><div class="line">&quot;coded_width&quot;: 1920,</div><div class="line">&quot;coded_height&quot;: 1088,</div><div class="line">&quot;has_b_frames&quot;: 2,</div><div class="line">&quot;sample_aspect_ratio&quot;: &quot;1:1&quot;,</div><div class="line">&quot;display_aspect_ratio&quot;: &quot;16:9&quot;,</div><div class="line">&quot;pix_fmt&quot;: &quot;yuv420p&quot;,</div></pre></td></tr></table></figure></p>
<p>分析上述样例视频的avinfo信息可知：</p>
<ul>
<li>分辨率=1920x108</li>
<li>sar=1:1</li>
<li>dar=16:9</li>
</ul>
<p>实际上，由于通常PAR=1:1，使得帧画面的宽高比=分辨率（即宽高像素数目）</p>
<p>此时，ffmpeg对于分辨率、sar、dar有如下公式：</p>
<p><em><strong>W/H * SAR = DAR</strong></em></p>
<p>上述样例视频，1920/1080 * (1/1) = 16:9</p>
<p>再看另外一个样例视频的<a href="http://ohgqsah1g.bkt.clouddn.com/water.mp4?avinfo" target="_blank" rel="external">视频信息</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;width&quot;: 480,</div><div class="line">&quot;height&quot;: 320,</div><div class="line">&quot;coded_width&quot;: 480,</div><div class="line">&quot;coded_height&quot;: 320,</div><div class="line">&quot;has_b_frames&quot;: 2,</div><div class="line">&quot;sample_aspect_ratio&quot;: &quot;32:27&quot;,</div><div class="line">&quot;display_aspect_ratio&quot;: &quot;16:9&quot;,</div><div class="line">&quot;pix_fmt&quot;: &quot;yuv420p&quot;,</div></pre></td></tr></table></figure></p>
<p>上述视频，480/320 * (32/27) = 16/9</p>
<h1 id="水印畸变"><a href="#水印畸变" class="headerlink" title="水印畸变"></a>水印畸变</h1><h2 id="播放形变"><a href="#播放形变" class="headerlink" title="播放形变"></a>播放形变</h2><p>一般视频终端播放是否发生形变，可以根据如下参数来判定：</p>
<ul>
<li>当SAR=1:1时，分辨率宽高比 = DAR，表示帧画面在终端播放时不会产生形变</li>
<li>当SAR!=1:1时，分辨率宽高比 != DAR，表示帧画面在终端播放时会产生形变</li>
</ul>
<h2 id="终端播放形变方式"><a href="#终端播放形变方式" class="headerlink" title="终端播放形变方式"></a>终端播放形变方式</h2><p>形变方式通常可以分为三种：</p>
<ol>
<li>保持短边不变，长边缩放</li>
<li>保持长边不变，短边缩放</li>
<li>长边短边同时缩放</li>
</ol>
<p>若以样例视频二为例，上述三种形变方式可得：</p>
<ol>
<li>原始画面480x320，短边保持不变，此时H=320,DAR=16/9，得W=320/9*16=569,即长边缩放比为569/480=1.185</li>
<li>原始画面480x320，长边边保持不变，此时W=480,DAR=16/9,得H=480/16*9=270，即短边的缩放比为270/320=0.84375</li>
<li>根据播放器实际情况发生变化</li>
</ol>
<h2 id="播放形变带来的水印形变"><a href="#播放形变带来的水印形变" class="headerlink" title="播放形变带来的水印形变"></a>播放形变带来的水印形变</h2><p>图片水印通常直接合成在原始帧画面中，故播放端的形变会连带造成水印产生畸变</p>
<p>以上述形变方式1为例，假设为原始视频打上一个40x40的方形水印，在终端播放时，长边会进行1.185倍的缩放，故实际水印显示大小约为47x40，畸变成为一个长方形水印</p>
<h1 id="图片水印畸变的解决方案"><a href="#图片水印畸变的解决方案" class="headerlink" title="图片水印畸变的解决方案"></a>图片水印畸变的解决方案</h1><p>在实际的生产应用中，有些需求水印要保持原始的长宽比，不能发生畸变，此时需要对图片水印畸变进行修正</p>
<h2 id="反向修正水印图片"><a href="#反向修正水印图片" class="headerlink" title="反向修正水印图片"></a>反向修正水印图片</h2><p>顾名思义，由于畸变发生在播放终端，故可以预测畸变行为，预先将水印图片变形后再压入原始帧画面，预变形图片会按预期畸变后恢复正常</p>
<p>以样例视频二为例，添加40x40的水印，假设采用第一种形变方式：</p>
<ol>
<li>计算可知，原始帧画面横边缩放比为1.185</li>
<li>反向压缩水印视频W=40/1.185=34，即将水印图片压缩成为34x40</li>
<li>终端播放，根据第一种形变方式，长边缩放，图片水印W’=34*1.185=40，即恢复到40x40的水印图片</li>
</ol>
<p>第二种形变方式处理方式相同</p>
<p><font color="red">上述方式存在问题</font>：</p>
<p>如果预测的形变方式与终端实际形变方式不同，可能造成水印图片等比缩放</p>
<p>比如，预测第一种形变方式，实际终端播放采用第二中形变方式：</p>
<ol>
<li>水印图片压缩后34x40</li>
<li>终端播放时，短边缩放比为0.84375，播放时水印高H=40*0.84375=34，即水印图片实际播放大小为34x34，即实际水印等比缩放了0.84375倍</li>
</ol>
<p>而若是终端播放采用第三种形变方式，则水印图片畸变不可预测，故修正后仍可能畸变</p>
<p><em>（由于播放形变取决的终端行为，故对水印畸变的情况并不能准确预测，不同的畸变模式的修正方式不一样，博主仅能据工作中的实际处理情况给出一些解决方案，欢迎大家指正）</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;摘要： 音视频添加图片水印时，SAR/DAR会造成图片水印随帧画面畸变。本文将分析畸变产生原因和探索解决方案&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="音视频处理" scheme="http://blog.snowwalf.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
    
      <category term="ffmpeg" scheme="http://blog.snowwalf.com/tags/ffmpeg/"/>
    
      <category term="音视频" scheme="http://blog.snowwalf.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="视频水印" scheme="http://blog.snowwalf.com/tags/%E8%A7%86%E9%A2%91%E6%B0%B4%E5%8D%B0/"/>
    
  </entry>
  
  <entry>
    <title>bochs+gdb源码级调试linux0.12内核测试环境构建</title>
    <link href="http://blog.snowwalf.com/2011/05/31/bochs-gdb-linux0-12-debug/"/>
    <id>http://blog.snowwalf.com/2011/05/31/bochs-gdb-linux0-12-debug/</id>
    <published>2011-05-31T06:12:00.000Z</published>
    <updated>2016-12-14T16:18:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>bochs+gdb搭建linux0.12内核源码调试环境</em><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前都是用的bochs自带的debug功能，但是linux内核大部分都是用C语vv言来实现的，若仅通过反汇编的汇编来学习，太累了。。。</p>
<p>所以今天花了一个上午的时间，搭建起了bochs+gbd的联调环境。</p>
<h1 id="安装bochs"><a href="#安装bochs" class="headerlink" title="安装bochs"></a>安装bochs</h1><p>首先还是要安装bochs，仍然是推荐使用最新的版本（2.4.6），如果使用像2.3.6等老版本，也许会导致后面与gdb无法远程连接（NND，就是这个恶心的问题浪费了我几个小时。。。）</p>
<p>linux上还是要从bochs的源码编译开始安装，bin文件安装的版本无法提供调试功能。</p>
<p>配置bochs源码时，输入命令 ./configure –enable-gdb-stub，然后使用make和sudo make install命令完成安装。</p>
<p>安装时可能会遇到X windows库不全的情况，可以通过apt-get安装xorg-dev解决。</p>
<p>如果是从source code进行编译安装时，有可能会用到的两个组件分别是build-essential和libxrandr-dev，各自作用请自行搜索～</p>
<h1 id="配置bochs"><a href="#配置bochs" class="headerlink" title="配置bochs"></a>配置bochs</h1><p>配置bochs虚拟机环境需要一个.bxrc文件和生产一个根文件系统镜像文件，建议直接到oldlinux上下载一个linux-0.11-gdb-rh9-050619.tar.gz，其中已经包含了配置好的这两个文件，另外在linux文件夹下有linux0.11的源码。</p>
<p>.bxrc文件中主要是添加了一条调试信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gdbstub: enable=1, port=1234, text_base=0, data_base=0, bss_base=0</div></pre></td></tr></table></figure></p>
<p>另外，这个bxrc文件中需要稍稍修改一些东西：</p>
<ol>
<li><p>romimage: file=$BXSHARE/BIOS-bochs-latest,  address=0xf0000 改成 romimage: file=$BXSHARE/BIOS-bochs-latest</p>
</li>
<li><p>floppy_command_delay: 50000 改成 #floppy_command_delay: 50000</p>
</li>
<li><p>3.ips: 4000000 改成 cpu: count=1, ips=4000000</p>
</li>
</ol>
<h1 id="使用bochs进行联机调试"><a href="#使用bochs进行联机调试" class="headerlink" title="使用bochs进行联机调试"></a>使用bochs进行联机调试</h1><ol>
<li>打开两个终端。</li>
<li>一个终端进入到linux-gdb-rh9/，运行程序”./run”，此时窗口显示等待信息“wait for gdb connection on localhost:1234”</li>
<li>另一个终端进入linux-gdb-rh9/linux/，运行 gdb tools/system</li>
<li>在gdb窗口中输入b main（在main函数处下断）</li>
<li>输入target remote localhost:1234 ，连接到bochs虚拟机上</li>
<li>输入c，让程序持续运行，直到终端在main函数中</li>
<li>可以开始使用gdb进行源码调试了^_^</li>
</ol>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li>早期源码默认的汇编编译器为gas，链接器为gld，所以在Makefile文件中显示声明as=gas ld=gld。而在ubuntu 11.04中，gcc早已成为默认的编译器了，所以如果是另外下载的源码，需要将Makefile中的as=gas ld=gld改成 as=as， ld=ld</li>
</ul>
<hr>
<p>先写到这，有在想到的继续啊~~~^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;bochs+gdb搭建linux0.12内核源码调试环境&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux内核" scheme="http://blog.snowwalf.com/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="linux" scheme="http://blog.snowwalf.com/tags/linux/"/>
    
      <category term="bochs" scheme="http://blog.snowwalf.com/tags/bochs/"/>
    
  </entry>
  
  <entry>
    <title>bochs的使用心得</title>
    <link href="http://blog.snowwalf.com/2011/05/28/bochs-experience/"/>
    <id>http://blog.snowwalf.com/2011/05/28/bochs-experience/</id>
    <published>2011-05-28T08:09:00.000Z</published>
    <updated>2016-12-14T16:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>bochs的使用和调试 linux内核<br><a id="more"></a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>bochs的简介吧，来自度娘：</p>
<blockquote>
<p>Bochs是一个x86硬件平台的开源模拟器。它可以模拟各种硬件的配置。Bochs模拟的是整个PC平台，包括I/O设备、内存和BIOS。更为有趣的是，甚至可以不使用PC硬件来运行Bochs。事实上，它可以在任何编译运行Bochs的平台上模拟x86硬件。通过改变配置，可以指定使用的CPU(386、486或者586)，以及内存大小等。一句话，Bochs是电脑里的“PC”。根据需要，Bochs还可以模拟多台PC，此外，它甚至还有自己的电源按钮。</p>
</blockquote>
<p>用下来感觉bochs非常小巧，相比于VM功能上并不相差很多，而且对于一些比较“古董”的硬件接口支持比较好，通过.bxrc文件能够很方便的生产和配置硬件。bochs内嵌的调试器比较好用，可以从虚拟机通电加载ROM BIOS起开始调试，对于了解操作系统的详细原理还是很有帮助的。就是没有图形化得调试界面比较蛋疼。。。用惯了VS,Windbg的人有点压力大。。。不过慢慢用就习惯了。</p>
<h1 id="获取bochs"><a href="#获取bochs" class="headerlink" title="获取bochs"></a>获取bochs</h1><p>可以去Sourceforge上下载src或者bin： <a href="http://bochs.sourceforge.net/" target="_blank" rel="external">http://bochs.sourceforge.net/</a>  （linux上建议还是从src开始编译，bin版本中往往不带有bochsdbg这个调试程序。。。windows的话可以直接用.exe的，安装完后是包含dbg程序的，所以我还是用的windows版^_^）</p>
<p>也可以去oldlinux上下载： <a href="http://oldlinux.org/Linux.old/bochs/" target="_blank" rel="external">http://oldlinux.org/Linux.old/bochs/</a><br>赵炯老师的书上建议调试Linux0.12使用的是bochs2.3.6，但经我实测发现最新的版本（现在是2.4.6）也是也是兼容的，而且2.4.6的调试指令相比老版本有不少的改进，所以还是建议使用最新的版本。</p>
<h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>安装和配置比较简单，windows的话只要下一步就OK；</p>
<p>linux上编译src需要在编译时设置编译选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/opt/bochs/debug --enable-plugins --enable-debugger --enable- disasm</div></pre></td></tr></table></figure>
<ul>
<li>–prefix=/opt/bochs/debug 软件将被安装到哪个目录下</li>
<li>–enable-plugins 是必须要的</li>
<li>–enable-debugger 是打开bochs的自带调试器</li>
<li>–enbale-disasm 允许反汇编</li>
</ul>
<h1 id="调试指令"><a href="#调试指令" class="headerlink" title="调试指令"></a>调试指令</h1><p>再来些bochsdbg的调试指令吧，网上搜的有些指令因为版本问题并不能使用（我用的是2.4.6）：</p>
<h2 id="普通指令组"><a href="#普通指令组" class="headerlink" title="普通指令组"></a>普通指令组</h2><table>
<thead>
<tr>
<th>指令格式</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>b addr</td>
<td style="text-align:left">在物理地址处设置断点 addr为物理内存地址，不加段基址</td>
</tr>
<tr>
<td>lb addr</td>
<td style="text-align:left">在线性地址处设置断点  addr为线性物理地址，不加基址</td>
</tr>
<tr>
<td>vb addr</td>
<td style="text-align:left">在虚拟地址上设置断点 addr为段基址：偏移地址， cs段</td>
</tr>
<tr>
<td>c</td>
<td style="text-align:left">继续执行知道遇到断点</td>
</tr>
<tr>
<td>n</td>
<td style="text-align:left">单步执行 跳过子程序和int中断程序</td>
</tr>
<tr>
<td>s</td>
<td style="text-align:left">单步执行</td>
</tr>
<tr>
<td>s num</td>
<td style="text-align:left">执行n步</td>
</tr>
<tr>
<td>dump_cpu</td>
<td style="text-align:left">查看寄存器信息（实测下来这个指令好像不好使）</td>
</tr>
<tr>
<td>x /nuf addr</td>
<td style="text-align:left">显示指定内存地址的数据，addr可以是线性的内存地址，也可以是虚址 格式是基址：偏移或者基址寄存器：偏移<br>n 显示的数据长度<br>u 数据单元大小 b,h,w,g分别对应1,2,4,8字节<br>f 数据显示格式 x,d,u,o,t,c分别对应十六进制、十进制、无符号十进制、八进制、二进制、字符串</td>
</tr>
<tr>
<td>u [/count] start end</td>
<td style="text-align:left">反汇编一段线性内存(作用与上面的一样)<br>(count 参数指明要反汇编的指令条数 ,例子：u /5 –反汇编从当前地址开始的5条指令)</td>
</tr>
</tbody>
</table>
<h2 id="info指令组"><a href="#info指令组" class="headerlink" title="info指令组"></a>info指令组</h2><table>
<thead>
<tr>
<th>指令格式</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>info b</td>
<td style="text-align:left">展示当前的断点状态信息</td>
</tr>
<tr>
<td>info dirty</td>
<td style="text-align:left">展示自从上次显示以来物理内存中的脏页（被写的页）</td>
</tr>
<tr>
<td>info program</td>
<td style="text-align:left">展示程序的执行状态（无法使用！）</td>
</tr>
<tr>
<td>info r/reg/rigisters</td>
<td style="text-align:left">展示寄存器内容</td>
</tr>
<tr>
<td>info cpu</td>
<td style="text-align:left">展示CPU寄存器内容</td>
</tr>
<tr>
<td>info fpu</td>
<td style="text-align:left">展示FPU寄存器的状态</td>
</tr>
<tr>
<td>info idt</td>
<td style="text-align:left">展示中断描述表</td>
</tr>
<tr>
<td>info ivt</td>
<td style="text-align:left">展示中断向量表(保护模式下无效)</td>
</tr>
<tr>
<td>info gdt</td>
<td style="text-align:left">展示全局描述表</td>
</tr>
<tr>
<td>info tss</td>
<td style="text-align:left">展示当前的任务状态段</td>
</tr>
<tr>
<td>info cr</td>
<td style="text-align:left">展示CR0-CR4寄存器状态 （无法使用）</td>
</tr>
<tr>
<td>info flags</td>
<td style="text-align:left">展示标志寄存器   （无法使用）</td>
</tr>
</tbody>
</table>
<h2 id="寄存器查询"><a href="#寄存器查询" class="headerlink" title="寄存器查询"></a>寄存器查询</h2><table>
<thead>
<tr>
<th>指令格式</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td style="text-align:left">查看通用寄存器</td>
</tr>
<tr>
<td>sreg</td>
<td style="text-align:left">查看段寄存器（es,cs,gs,ss,fs,ds以及idt,gdt,ldt,tr）</td>
</tr>
<tr>
<td>creg</td>
<td style="text-align:left">查看控制寄存器（cr0，cr1，cr2，cr3）</td>
</tr>
<tr>
<td>dreg</td>
<td style="text-align:left">查看调试寄存器（dr0-dr7）</td>
</tr>
</tbody>
</table>
<p>这里再插一句，标志寄存器的查看方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eflags 0x00000002: id vip vif ac vm rf nt IOPL=0 of df if tf sf zf af pf cf    （均未置位）</div><div class="line"></div><div class="line">eflags 0x00000046: id vip vif ac vm rf nt IOPL=0 of df if tf sf ZF af PF cf （ZF,PF置位）</div></pre></td></tr></table></figure></p>
<p>0x00000002是标志寄存器的实际数值，后面的zf，sf等为标志位，小写时标志位未置位，大写为已置位。</p>
<h1 id="在linux0-12系统上编译0-12内核："><a href="#在linux0-12系统上编译0-12内核：" class="headerlink" title="在linux0.12系统上编译0.12内核："></a>在linux0.12系统上编译0.12内核：</h1><ul>
<li><p>从前文下载的根文件系统rootimage-0.12上已经包含了0.12内核的源码，位于/usr/src/linux。</p>
</li>
<li><p>使用make命令编译源码，生成引导区启动镜像文件Image。</p>
</li>
<li><p>通过命令dd bs=8192 if=Image of=/dev/fd0 将生成的镜像输出到虚拟软盘文件bootimage-0.12-hd上（记得先备份一个啊！），再次启动bochs，即可由新的镜像引导启动了。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bochs的使用和调试 linux内核&lt;br&gt;
    
    </summary>
    
      <category term="Linux内核" scheme="http://blog.snowwalf.com/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="linux" scheme="http://blog.snowwalf.com/tags/linux/"/>
    
      <category term="bochs" scheme="http://blog.snowwalf.com/tags/bochs/"/>
    
      <category term="调试" scheme="http://blog.snowwalf.com/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>A20地址线的一点理解</title>
    <link href="http://blog.snowwalf.com/2011/05/27/a20-bus/"/>
    <id>http://blog.snowwalf.com/2011/05/27/a20-bus/</id>
    <published>2011-05-27T11:30:00.000Z</published>
    <updated>2016-12-14T16:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>A20地址线 Linux内核实现及系统启动引导</em><br><a id="more"></a></p>
<h2 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h2><p>先来看看A20地址线的由来和历史遗留问题（纯搬运）：</p>
<blockquote>
<p>   1981年8月，IBM公司最初推出的个人计算机IBM PC使用的CPU是Intel 8088。在该微机中地址线只有20根(A0 – A19)。在当时内存RAM只有几百KB或不到1MB时，20根地址线已足够用来寻址这些内存。其所能寻址的最高地址是0xffff:0xffff，也即0x10ffef。对于超出0x100000(1MB)的寻址地址将默认地环绕到0x0ffef。当IBM公司于1985年引入AT机时，使用的是Intel 80286 CPU，具有24根地址线，最高可寻址16MB，并且有一个与8088完全兼容的实模式运行方式。然而，在寻址值超过1MB时它却不能象8088那样实现地址寻址的环绕。但是当时已经有一些程序是利用这种地址环绕机制进行工作的。为了实现完全的兼容性，IBM公司发明了使用一个开关来开启或禁止0x100000地址比特位。由于在当时的8042键盘控制器上恰好有空闲的端口引脚（输出端口P2，引脚P21），于是便使用了该引脚来作为与门控制这个地址比特位。该信号即被称为A20。如果A20为零，则比特20及以上地址都被清除。从而实现了兼容性。</p>
</blockquote>
<p>由于在机器启动时，默认条件下，A20地址线是禁止的，所以操作系统必须使用适当的方法来开启它。但是由于各种兼容机所使用的芯片集不同，要做到这一点却是非常的麻烦。因此通常要在几种控制方法中选择。</p>
<h2 id="A20地址线的控制"><a href="#A20地址线的控制" class="headerlink" title="A20地址线的控制"></a>A20地址线的控制</h2><p>对A20信号线进行控制的常用方法是通过设置键盘控制器的端口值。下面引用一段linux0.11的源码（setup.s）:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">	call 	empty_8042</div><div class="line"> </div><div class="line">	mov	al,#0xd1</div><div class="line">	out	#0x64,al</div><div class="line">	call	empty_8042</div><div class="line">	mov	al,#0xdf</div><div class="line">	out	#0x60,al</div><div class="line">	call	empty_8042</div><div class="line"> </div><div class="line">...</div><div class="line"> </div><div class="line">empty_8042:</div><div class="line">	.word 0x00eb,0x00eb</div><div class="line">	in 	al,#0x64</div><div class="line">	test	al,#2</div><div class="line">	jnz	empty_8042</div><div class="line">	ret</div></pre></td></tr></table></figure></p>
<p>贴一下啊head.s中的代码(这里转成Intel汇编格式，源码是AT&amp;A汇编，看着蛋疼。。)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	xor eax,eax</div><div class="line">l:</div><div class="line">	inc eax</div><div class="line">	mov [0x000000],eax;</div><div class="line">	cmp [0x100000],eax;</div><div class="line">	je lb</div></pre></td></tr></table></figure></p>
<p>向0x000000字节处数据改为1，查看0x100000处数据是否同时变成了1，若是则A20地址线没用开启；否则开启成功。</p>
<h2 id="Intel-8042芯片"><a href="#Intel-8042芯片" class="headerlink" title="Intel 8042芯片"></a>Intel 8042芯片</h2><p>解释一下Intel 8042芯片（又是搬运。。。）：</p>
<blockquote>
<p>   ntel8024是intel公司的一款键盘控制器芯片,它为x86系统中的标准配置.虽然名为键盘控制器,但是鼠标也是由其控制的.<br>    键盘通常使用IRQ1.鼠标通常使用IRQ12.IRQ1和IRQ12都是连接在键盘控制器上的.对应intel8042的两个端口.</p>
</blockquote>
<pre><code>配给键盘控制器的I/O端口有四个,分别是0x60~0x64.在大部分情况中,只会使用到0x60和0x64.其余0x61~0x64的存在主要是为了兼容XT.可以将0x64看做是状态寄存器.0x60看成是数据寄存器.有时在给键盘控制器下指令的时候,这两个端口都要用到.两者配合来达到下指令与参数的目的.
</code></pre><h2 id="向i8042发送命令"><a href="#向i8042发送命令" class="headerlink" title="向i8042发送命令:"></a>向i8042发送命令:</h2><ol>
<li>我们需要先把命令发送到0x64端口，</li>
<li>然后紧接着把这个命令的参数发送到0x60端口，</li>
<li>然后我们可以通过读0x60端口，获得i8042返回给我们的数据。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;A20地址线 Linux内核实现及系统启动引导&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Linux内核" scheme="http://blog.snowwalf.com/categories/Linux%E5%86%85%E6%A0%B8/"/>
    
    
      <category term="linux" scheme="http://blog.snowwalf.com/tags/linux/"/>
    
  </entry>
  
</feed>
